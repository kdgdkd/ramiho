#!/bin/bash
# ramiho - raspi midi host
# Cliente de Teclado Numérico Raspi MIDI host
# kdg/dkd - kódigo diskordia en edpanfleto.com/kdgdkd/
# LOCALE************************************************
fLOCALE_ES () {
txconf_locale="ES"
tx_localch="ramiho en castellano"
tx_sndon="con sonido"
tx_sndoff="silenciado"
tx_checkfavdev="Chequea dispositivos favoritos:"
tx_errnofavdev="  No se encontraron dispositivos favoritos conectados a ramiho"
tx_retrmh=" Volver a ramiho"
tx_errsel="Error introduciendo selección"
tx_cnx="ramiho_fav> "
tx_mdshprompt="ramiho_midish> "
tx_svcnx="  Guardar conexiones actuales"
tx_svpos="Elegir posición (1, 2, 3, o 0 para nuevo fichero)> "
tx_svd="Conexiones guardadas:"
tx_mdshsvd="Conexiones guardadas en "
tx_ldcnx="Cargar conexiones guardadas "
tx_midishfront=" Rutear canales y puertos"
tx_midishfr2=" Definiendo puertos, canales y conexiones, déja la respuesta en blanco para pasar al siguiente"
tx_ctlc="    Ctrl + C para salir"
tx_mdshdel="Borrar ruteos MIDI"
tx_rdport="Leer puerto N"
tx_rdportprmpt="N del puerto> "
tx_errnpt1="     El puerto número "
tx_errnpt2=" no existe"
tx_lstcnx="Lista de conexiones"
tx_err0cnx=" ! No hay conexiones activas"
tx_lstcnxprt="Lista de puertos y conexiones"
tx_lstprt="Lista de puertos disponibles"
tx_hdprt="     N   Puerto Nombre"
tx_lstusb="Lista de dispositivos USB conectados"
tx_cnxinp1="Introduce puertos usando N del puerto o el formato .14.0
También puede utilizar * para representar el resto de puertos"
tx_cnxinppr1="Primer puerto> "
tx_cnxinppr2="Segundo puerto> "
tx_errprt=" !! Error introduciendo puertos"
tx_midicnx="Conexión MIDI entre puertos"
tx_errcnx="Error, no se ha podido conectar"
tx_midicnxex="Conectar puertos de forma exclusiva"
tx_mididcnt="Desconectar puertos"
tx_cnctall="Conectando todos los clientes entre sí"
tx_clsall="Cerrando todas las conexiones MIDI"
tx_smprompt="ramiho_sendmidi> "
tx_monprompt="ramiho_monitor> "
tx_monfrhd="Enter para comenzar monitor de "
tx_montyp="Tipo de Monitor"
tx_monclt="Cliente "
tx_arrtyphd="Seleccionar puerto (arriba / abajo)"
tx_arrtphd2="Sel  N   [puerto]  Cliente"
tx_arrtphd3="Seleccionar tipo de monitor (RePag / AvPag)"
tx_anyky="Pulsa cualquier tecla para salir del monitor"
tx_mondeac="Desactivando monitor de "
tx_errcli="Error, no se identificó el cliente"
tx_prt2allhd="Conectar a todos los puertos"
tx_all2prthd="Conectar desde todos los puertos"
tx_monhd2="Monitor MIDI de puerto N"
tx_lstprthd="Sel  N    Cliente  [puerto]    Canal ch    Nota n"
tx_detcnxprt="ALSA Detalle de conexiones"
tx_acn="ramiho_aconnect> "
tx_erraconf="Primero carga conexiones en la memoria"
tx_seemdsh="Detalles de la última conexión con aconnect"
tx_mdshoutin="Crea dispositivos de entrada"
tx_mdshoutout="Crea dispositivos de salida"
tx_mdshprtin="N de puerto de envío "
tx_mdshchin="    Canal MIDI envío "
tx_mdshprtout="N de puerto de recepción "
tx_mdshchout="    Canal MIDI recepción "
tx_mdshlstin="Lista dispositivos de entrada"
tx_mdshlstout="Lista dispositivos de salida"
tx_mdshcnxhd="Conecta los dispositivos de entrada con los de salida"
tx_mdshpchhd="Envía program change a dispositivo"
tx_mdshpdevup="Actualiza dispositivos midish"
tx_mdshtrphd="Traspone notas de dispositivo de salida (st)"
tx_mdshvelhd="Ajustar velocidad de dispositivo de salida (-63..63)"
tx_mdshcnxin="Conectar dispositivo de entrada > "
tx_mdshcnxout=$'\U2192'"con dispositivo de salida > "
tx_mdshdevout="Dispositivo > "
tx_mdshtrans="   trasponer (st) > "
tx_mdshpgchg="   program change > "
tx_mdshveladj="   ajuste vel. (-63..63) > "
tx_mdshsnd="Enviando..."
tx_errmdshf="Define primero una conexión con midish"
tx_seemdsh="Detalles de la última conexión con midish"
tx_exitsl="  /   para salir> "
tx_exitout="  Saliendo..." 
tx_monheader='ramiho >> monitor MIDI
*******************************************************'
tx_montyp="
aseqdump   completo
note       notas
cc         control change
psc        transport
pc         program change
syx        sysex
rpn        rpn
sr         all System Real-Time messages
sc         all System Common messages"
tx_frshhlp="        ...> "
tx_hlptermhd1='ramiho Rpi MIDI Host - AYUDA
********************************************
     +     Conectar puertos
     -     Desconectar puertos
    BSp    Conectar en modo exclusivo
     *     Conectar / Desconectar todo
     .     Desconectar todo
     0     Menú Conexiones Favoritas

     1     Lista de puertos y conexiones
     2     Detalles ALSA MIDI
     3     Detalles dispositivos USB

     4     Monitor puerto MIDI
     5     Enviar señal MIDI
     6     Leer puerto N

     7     Front-end aconnect
     8     Front-end midish
	 
     9     Mostrar Ayuda
     99    Leer IP y Ayuda
     98    Activar/Desactivar sonido
     97    Cambiar idioma
	 
    FNC    Leer el puerto n
     //    Para salir
********************************************'
txhlpcli='ramiho Rpi MIDI Host - Ayuda Linea de Comandos
*************************************************************
Uso:
ramiho               abrir interface en terminal
ramiho $1 $2$3       argumentos para uso en línea de comandos

argumentos: 
   +   > Conectar puertos
 +$1$2 > Conectar puerto número $1 al puerto número $2
   -   > Desconectar puertos
 -$1$2 > Desconectar puerto número $1 del puerto número $2
 
   .   > Desconectar todo
   0   > Menú Conexiones Favoritas
   0$1 > Cargar Conexión Favorita número $1
   1   > Lista de puertos y conexiones
   2   > Mostrar detalles ALSA MIDI
   3   > Mostrar dispositivos USB
   4   > Monitor puerto MIDI
   5   > Enviar señal MIDI
   6   > Leer puerto N
   6$1 > Leer puerto $1
   7   > front-end aconnect
   8   > front-end midish
   9   > Mostrar IP y Ayuda'

tx_monhd="ramiho >> Elegir puerto y tipo de monitor MIDI
********************************************************************"

tx_smhdr="ramiho >> Enviar señal MIDI
************************************************
   Enter   envía nota
    + -    cambiar nota
    3 9    cambiar octava
    4 6    cambiar canal MIDI
    2 8    cambiar cliente
    0 .    panic
     1     alternar tipo de cliente (hw o virtual)
     7     cargar valores por defecto
     5     enviar secuencia
     /     volver
   FUNC    leer el puerto n
************************************************"

}
fLOCALE_EN () {
txconf_locale="EN"
tx_localch="ramiho in English"
tx_sndon="Sound on"
tx_sndoff="Sound off"
tx_checkfavdev="Check favorite devices:"
tx_errnofavdev="  No favorite devices connected"
tx_retrmh=" Return to ramiho"
tx_errsel="Error introducing selection"
tx_cnx="ramiho_fav> "
tx_mdshprompt="ramiho_midish> "
tx_svcnx="  Save current connexions"
tx_svpos="Choose position (1, 2, 3, or 0 for new file)> "
tx_svd="Saved connexions:"
tx_mdshsvd="Connexions saved in "
tx_ldcnx="Load saved connexions "
tx_midishfront=" Reroute ports and channels"
tx_midishfr2=" When defining connexions, leave source device empty to send midish filter"
tx_ctlc="    Ctrl + C to exit"
tx_mdshdel="Delete MIDI routings"
tx_rdport="Reed port N"
tx_rdportprmpt="Port N> "
tx_errnpt1="     Port number "
tx_errnpt2=" does not exist"
tx_lstcnx="List of connexions"
tx_err0cnx=" No active connexions!"
tx_lstcnxprt="List of ports and connexions"
tx_lstprt="List of available ports"
tx_hdprt="     N   Port   Name"
tx_lstusb="List of USB buses"
tx_cnxinp1="Enter ports using the position (N) of the port, or format .14.0 (for port 14:0)
You may use * as a wildcard for every other port"
tx_cnxinppr1="First port> "
tx_cnxinppr2="Second port> "
tx_errprt=" Error entering ports"
tx_midicnx="MIDI connexion between ports"
tx_errcnx="Error, couldn't connect"
tx_midicnxex="Exclusive MIDI connexion between ports"
tx_mididcnt="Disconnect ports"
tx_cnctall="Connect all ports with each other"
tx_clsall="Close all MIDI connexions"
tx_smprompt="ramiho_sendmidi> "
tx_monprompt="ramiho_monitor> "
tx_monfrhd="Enter to start monitor for "
tx_montyp="Type of Monitor"
tx_monclt="Client "
tx_arrtyphd="Choose port (up / down)"
tx_arrtphd2="Sel  N   [port]   Client"
tx_arrtphd3="Choose type of monitor (RePag / AvPag)"
tx_anyky="Press any key to exit the monitor"
tx_mondeac="Closing monitor for "
tx_errcli="Error, client not identified"
tx_prt2allhd="Connect to all ports"
tx_all2prthd="Connect from all ports"
tx_monhd2="MIDI monitor for port N"
tx_lstprthd="Sel  N    Client   [port]       Channel    Note n"
tx_detcnxprt="ALSA Detailed connexions"
tx_acn="ramiho_aconnect> "
tx_erraconf="First load connexions to memory"
tx_seeacon="Last aconnect connexion details"
tx_mdshoutin="Create input devices"
tx_mdshoutout="Create ouput devices"
tx_mdshprtin="N input port "
tx_mdshchin="   input MIDI channel "
tx_mdshprtout="N output port "
tx_mdshchout="   output MIDI channel "
tx_mdshlstin="Input devices"
tx_mdshlstout="Output devices"
tx_mdshcnxhd="Connect input devices with output devices"
tx_mdshpchhd="Send program change to device"
tx_mdshpdevup="Update midish devices"
tx_mdshtrphd="Transpose notes on output device (ht)"
tx_mdshvelhd="Adjust velocity on output device (-63..63)"
tx_mdshcnxin="Connect device > "
tx_mdshcnxout=" "$'\U2192'" with device > "
tx_mdshdevout="Device > "
tx_mdshtrans="   transpose (ht) > "
tx_mdshpgchg="   program change > "
tx_mdshveladj="   adj. vel. (-63..63) > "
tx_mdshsnd="Sending..."
tx_errmdshf="First create a define new midish connexions"
tx_seemdsh="Last midish connexion details"
tx_exitsl="  /   to exit> "
tx_exitout="  Bye..." 
tx_monheader='ramiho >> MIDI monitor
*******************************************************'
tx_montyp="
aseqdump   completo
note       notas
cc         control change
psc        transport
pc         program change
syx        sysex
rpn        rpn
sr         all System Real-Time messages
sc         all System Common messages"
tx_frshhlp="        ...> "
tx_hlptermhd1='ramiho Rpi MIDI Host - HELP
**********************************
     +     Connect ports
     -     Disconnect ports
    BSp    Connect ports on exclusive mode
     *     Connect / Disconnect all
     .     Disconnect all 
     0     Favorite Connexions menu

     1     List of ports and connexions
     2     ALSA MIDI details
     3     USB devices details

     4     Monitor MIDI port
     5     Send MIDI signal to port
     6     Read port N

     7     aconnect front-end
     8     midish front-end
	 
     9     Show Help
     99    Read IP and Help
     98    Enable/disable sound
     97    Change language
	 
    FNC    Read port N
     //    To Exit
**********************************'
txhlpcli='ramiho Rpi MIDI Host - CLI HELP
**********************************
Usage:
ramiho               open terminal interface
ramiho $1 $2$3       arguments for command line

arguments: 
   +   > Connect ports
 +$1$2 > Connect port number $1 to port number $2
   -   > Disconnect ports
 -$1$2 > Disconnect port number $1 from port number $2
 
   .   > Disconnect all
   0   > Favorite Connexions menu
   0$1 > Load Favorite Connexion number $1
   1   > List of ports and connexions
   2   > ALSA MIDI details
   3   > USB devices details
   4   > Monitor MIDI port
   4$1 > Monitor port number $1
   5   > Send MIDI signal to port
   6   > Read port N
   6$1 > Provide information on port number $1
   7   > aconnect front-end
   8   > midish front-end
   9   > This help and IP'

tx_monhd="ramiho >> Choose port and type of monitor
********************************************************************"
tx_smhdr="ramiho >> Send MIDI signal
************************************************
   Enter   send note
    + -    change note
    3 9    change octave
    4 6    change MIDI channel
    2 8    change client
    0 .    panic
     1     change type of client (hw o virtual)
     7     reload default values
     5     send sequence
     /     exit
   FUNC    read port n
************************************************"

}

# CONFIGURATION***********************************************************
fCONF () {  # customize
sendmidi="$SCRIPT_DIR/srmidi/sendmidi"
receivemidi="$SCRIPT_DIR/srmidi/receivemidi"
midiseq="$SCRIPT_DIR/srmidi/sendmidifile"
tts="festival --tts"  #define text-to-sound engine
soundon='false' # change to false to mute by default
writeprotection='true'
fLOCALE_EN # Change this to your preferred locale
}
fCONF
fCONF_FILES () {
SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]:-$0}"; )" &> /dev/null && pwd 2> /dev/null; )"
midishsvdfiles=("$SCRIPT_DIR/favcnx/mdshsvd"*)
aconsvdfiles=("$SCRIPT_DIR/favcnx/aconsvd"*)
afavcnxfiles=("$SCRIPT_DIR/favcnx/"*)
apersconfiles=()
for dupl in ${midishsvdfiles[@]}; do
	afavcnxfiles=( "${afavcnxfiles[@]/$dupl}" )
done
for dupl in ${aconsvdfiles[@]}; do
	afavcnxfiles=( "${afavcnxfiles[@]/$dupl}" )
done
for empty in ${afavcnxfiles[@]}; do
	if [[ "$empty" != '' ]]; then
		apersconfiles+=("$empty")
	fi
done
afavcnxfiles=()
afavcnxfiles+=(${apersconfiles[@]} ${aconsvdfiles[@]} ${midishsvdfiles[@]})
}
fCONF_FILES
fCONF_LOCALE () { 
_bold
echo
if [[ $txconf_locale == 'ES' ]]; then
	fLOCALE_EN
	echo "$tx_localch"
else
	fLOCALE_ES
	echo "$tx_localch"
fi
_norm
}
fCONF_MUTE () { 
if [[ $soundon == 'true' ]]; then
	soundon='false'
	ttstmp=
	echo "$tx_sndoff"
else
	soundon='true'
	ttstmp="Sound on"
	echo "$tx_sndon"
fi
}

# FORMAT*******************
_bold () { 
tput bold
}
_norm () { 
tput sgr0
}
_blanco () { 
tput setaf 7 
}
_amarillo () {
tput setaf 3
}
_verde () {
tput setaf 2
}

# CONEXIONES FAVORITAS--FAVORITE CONNEXIONS*********************************************
fFCN_HEADER () {  # customize
_bold
echo "ramiho >> Menu de conexiones favoritas
********************************************************************
     +     Conectar puertos
     -     Desconectar puertos
     *     Chequear dispositivos favoritos
     .     Desconectar todo
     0     Cargar fichero
	 
     1     aconnect: KeyStep y UC33 a Uno MIDI
     2     aconnect: KeyStep & UC-33 a Blofeld y Uno MIDI
     3     aconnect: X-Touch mini a Launchpad
	 
     4     midish: KeyStep y UC33 -> USB MIDI + Master
             [KSP:   ch1..15->ch1..15]
             [UC33e: ch1..15->ch1..15 / Master ch16->ch1..15]
     5     midish: KeyStep Pro & UC33e -> USB MIDI + Master
             [KSP:   ch1->ch1,2,12 / ch3->ch3,4
				     / ch5->ch5,6 / ch7->ch7,8,9]
             [UC33e: ch1..15->ch1..15 / Master ch16->ch1..15]
     6     midish: KeyStep Pro & UC33e -> USB MIDI + Master
             [KSP:   ch1->ch1,2,12&ch13(+7st) / ch3->ch3,4&ch14(+7st)
				     / ch5->ch5,6&ch15(+7st) / ch7->ch7,8,9&ch10(+7st)]
             [UC33e: ch1..15->ch1..15 / Master ch16->ch1..15]
	  
     7     Front-end aconnect
     8     Front-end midish
     9     Mostrar esta ayuda
     /     Volver a ramiho
********************************************************************"
_norm
}
fFCN_ACT () { # customize
if [[ $1 != "" ]]; then  # si no (vacio)=ENTER
	if [[ $1 = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		echo
		case $1 in
			[.]) fMSH_DEL; fCNX_DISCONNECTALL;;
			[0]) fFCN_SELFILE;; 
			[1]) fFCN_LOADFILE "$SCRIPT_DIR/favcnx/aconKSPUC33unousb"; fLST_CONNEX;; 
			[2]) fFCN_LOADFILE "$SCRIPT_DIR/favcnx/aconKSPUC33blofeld"; fLST_CONNEX;;  
			[3]) fFCN_LOADFILE "$SCRIPT_DIR/favcnx/aconXTOUCHlaunchpad"; fLST_CONNEX;;  
			[4]) fFCN_LOADFILE "$SCRIPT_DIR/favcnx/mdsh1a1master";;  
			[5]) fFCN_LOADFILE "$SCRIPT_DIR/favcnx/mdsh1a2master";; 
			[6]) fFCN_LOADFILE "$SCRIPT_DIR/favcnx/mdsh1a3quinmaster";;   
			[7]) fACN_FRONT; lpbrk=true;; 
			[8]) fMSH_FRONT; lpbrk=true;;   
			[9]) fFCN_HEADER;;    
			[+]) fCNX_OPS 'cnx'
				fLST_CONNEX;; 
			[-]) fCNX_OPS 'dcnx'
				fLST_CONNEX;;   
			[*]) fFCN_DEVICE;; 
			*) ci_err1=true;;
		esac
	fi
[[ $ci_err1 == true ]] && echo $tx_errsel && [[ $soundon == 'true' ]] && echo "Error, no setup selected" | $tts > /dev/null 2>&1 &
fi
}
fFCN_FRONT () {
lpbrk=
setup=
ci_err1=false
ci_err2=false
[[ $soundon == 'true' ]] && echo "favorite connexions" | $tts > /dev/null 2>&1 &
	clear
	fFCN_HEADER
while true; do
	_bold
	_amarillo
	read -n 1 -p $tx_cnx setup 
	read -t 0.01 resto
	[[ $setup == '/' ]] && echo "$tx_retrmh" && break
	_norm
	fFCN_ACT "$setup"
	[[ $lpbrk == 'true' ]] && break 
done
}
fFCN_DEVICE () { #checks if the devices in the list are connected  # customize
clfav=
_bold && echo "$tx_checkfavdev" && _norm
iconnection=`aconnect -i -l`
	[[ "$iconnection" == *"Virus"* ]] && clfav="$clfav 
  Access Virus TI on"
	[[ "$iconnection" == *"BCR"* ]] && clfav="$clfav 
  BCR2000 on"
	[[ "$iconnection" == *"UC-33"* ]] && clfav="$clfav 
  Evolution UC-33 on"
	[[ "$iconnection" == *"KeyStep"* ]] && clfav="$clfav 
  Arturia KeyStep on"
	[[ "$iconnection" == *"BeatStep"* ]] && clfav="$clfav 
  Arturia BeatStep on"
	[[ "$iconnection" == *"AR-96"* ]] && clfav="$clfav 
  Zoom ARQ AR-96 on"
	[[ "$iconnection" == *"USB Uno MIDI"* ]] && clfav="$clfav 
  USB Uno MIDI Interface on"
	[[ "$iconnection" == *"minilogue"* ]] && clfav="$clfav 
  Korg Minilogue XD on"
	[[ "$iconnection" == *"launchpad"* ]] && clfav="$clfav 
  Novation Launchpad"
	[[ "$iconnection" == *"blofeld"* ]] && clfav="$clfav 
  Waldorf Blofeld on"
	[[ "$iconnection" == *"X-TOUCH"* ]] && clfav="$clfav 
  X-Touch Mini on"
	[[ "$iconnection" == *"QUNEO"* ]] && clfav="$clfav 
  QuNeo on"
if [[ $clfav == '' ]]; then
	[[ $soundon == 'true' ]] && echo "No favorites connected" | $tts > /dev/null 2>&1 &
	echo $tx_errnofavdev 
else
	[[ $soundon == 'true' ]] && echo "$clfav" | $tts > /dev/null 2>&1 &
	echo "$clfav"
fi
}
fFCN_SELFILE () {
fCONF_FILES
if [[ $1 =~ ^-?[0-9]+$ ]]; then
	preset=$1
else
	listaficheros="Cargar fichero de ramiho/favcnx
	 N    File"
	[[ $soundon == 'true' ]] && echo "Load file number " | $tts > /dev/null 2>&1 &
	let icontN=1
	for i in "${!afavcnxfiles[@]}"; # por cada puerto MIDI existente (arrCliente en lugar de arrPuerto)
	do
		persofile="${afavcnxfiles[$i]}"
		persofile=${persofile/"$SCRIPT_DIR/favcnx/"/}
		listaficheros="$listaficheros
	 $icontN    $persofile"
		let icontN=$icontN+1
	done
	_bold && echo "$listaficheros" && _norm
	read -p "Cargar fichero > " preset 
	echo
fi
if [[ $preset =~ ^-?[0-9]+$ ]] && [[ $preset -lt $icontN ]]; then
	[[ $soundon == 'true' ]] && echo "Loading file number $preset" | $tts > /dev/null 2>&1 &
	let preset=$preset-1
	fFCN_LOADFILE "${afavcnxfiles[$preset]}"
else
	echo "$tx_errsel"
	[[ $soundon == 'true' ]] && echo "Error choosing file" | $tts > /dev/null 2>&1 &
fi
}
fFCN_SAVENEW () {
let iCuenta=1
while [[ -f "$SCRIPT_DIR/favcnx/ramihocnx$iCuenta" ]];
do
	let iCuenta=$iCuenta+1
done
savedconnexions="$SCRIPT_DIR/favcnx/ramihocnx$iCuenta"
touch "$SCRIPT_DIR/favcnx/ramihocnx$iCuenta"
}
fFCN_LOADFILE () {
if grep -q "aconnect" $1; then
	fACN_LOADFILE $1
elif grep -q "dnew" $1; then
	fMSH_LOADFILE $1
fi
}
fFCN_WRITEPROTECT () {
if [[ $writeprotection == 'true' ]]; then
	if [[ $1 == 'off' ]]; then
		echo "rw" | bash 
	elif [[ $1 == 'on' ]]; then
		echo "ro" | bash 
	fi
fi
}

# aconnect front-end*********************************************
fACN_HEADER () {  # customize
	_bold
echo "ramiho >> acconnect front-end
********************************************************************
     +     Conectar puertos
     -     Desconectar puertos
     *     Ver conexión en memoria
     .     Cargar conexión en memoria
     0     Guardar memoria a fichero
	 
     1     Cargar conexiones guardadas (1)
     2     Cargar conexiones guardadas (2)
     3     Cargar conexiones guardadas (3)
	 
     4     Conectar KeyStep y UC33 a Uno MIDI
     5     Conectar KeyStep & UC-33 a Blofeld y Uno MIDI
     6     Conectar KeyStep, UC-33, USB Uno MIDI a Virus por USB
	  
     7     Front-end midish
     8     Conexiones Favoritas
     9     Mostrar esta ayuda
     /     Volver a ramiho
********************************************************************"
_norm
}
fACN_ACT () { # customize
if [[ $1 != "" ]]; then  # si no (vacio)=ENTER
	if [[ $1 = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		echo
		case $1 in 
			[*]) fACN_SEECNX;;
			[.]) fACN_START;;
			[0]) fACN_SAVEFILE;; 
			[1]) fACN_LOADFILE "${aconsvdfiles[1]}"; fLST_CONNEX;; 
			[2]) fACN_LOADFILE "${aconsvdfiles[2]}"; fLST_CONNEX;;  
			[3]) fACN_LOADFILE "${aconsvdfiles[3]}"; fLST_CONNEX;;  
			[4]) fACN_1; fLST_CONNEX;;  
			[5]) fACN_2; fLST_CONNEX;; 
			[6]) fACN_3; fLST_CONNEX;;   
			[7]) fMSH_FRONT; lpbrk=true;; 
			[8]) fFCN_FRONT; lpbrk=true;;   
			[9]) fACN_HEADER;;    
			[+]) fCNX_OPS 'cnx'
				fLST_CONNEX;; 
			[-]) fCNX_OPS 'dcnx'
				fLST_CONNEX;;   
			*) ci_err1=true;;
		esac
	fi
[[ $ci_err1 == true ]] && echo $tx_errsel && [[ $soundon == 'true' ]] && echo "Error, no setup selected" | $tts > /dev/null 2>&1 &
fi
}
fACN_FRONT () {
lpbrk=
setup=
ci_err1=false
ci_err2=false
[[ $soundon == 'true' ]] && echo "a connect front end" | $tts > /dev/null 2>&1 &
	clear
	fACN_HEADER
	fLST_CONNEX
while true; do
	_bold
	_amarillo
	read -n 1 -p $tx_acn setup 
	read -t 0.01 resto
	[[ $setup == '/' ]] && echo "$tx_retrmh" && break
	_norm
	fACN_ACT "$setup"
	[[ $lpbrk == 'true' ]] && break 
done
}
fACN_1 () {  # customize
aconnect -x
_bold && echo " Conectar KeyStep & UC-33 a Uno MIDI" && _norm
aconnect 'UC-33 USB MIDI Controller':0 'USB Uno MIDI Interface':0
aconnect 'KeyStep Pro':0 'USB Uno MIDI Interface':0 
aconout="aconnect 'UC-33 USB MIDI Controller':0 'USB Uno MIDI Interface':0
aconnect 'KeyStep Pro':0 'USB Uno MIDI Interface':0 "
}
fACN_2 () {  # customize
aconnect -x
_bold && echo " Conectar KeyStep & UC-33 a Blofeld y Uno MIDI" && _norm
aconnect 'UC-33 USB MIDI Controller':0 'USB Uno MIDI Interface':0
aconnect 'KeyStep Pro':0 'USB Uno MIDI Interface':0 
aconnect 'UC-33 USB MIDI Controller':0 'Blofeld':0
aconnect 'KeyStep Pro':0 'Blofeld':0 
aconout="aconnect 'UC-33 USB MIDI Controller':0 'USB Uno MIDI Interface':0
aconnect 'KeyStep Pro':0 'USB Uno MIDI Interface':0 
aconnect 'UC-33 USB MIDI Controller':0 'Blofeld':0
aconnect 'KeyStep Pro':0 'Blofeld':0 "
}
fACN_3 () {  # customize
aconnect -x
_bold && echo " Conectar KeyStep, UC-33, USB Uno MIDI a Virus por USB" && _norm
aconnect 'UC-33 USB MIDI Controller':0 'Virus TI':1
aconnect 'KeyStep Pro':0 'Virus TI':1
aconnect 'Arturia BeatStep Pro':0 'Virus TI':1
aconnect 'USB Uno MIDI Interface':0 'Virus TI':1
aconnect 'QUNEO' 'Virus TI':1
aconout="aconnect 'UC-33 USB MIDI Controller':0 'Virus TI':1
aconnect 'KeyStep Pro':0 'Virus TI':1
aconnect 'Arturia BeatStep Pro':0 'Virus TI':1
aconnect 'USB Uno MIDI Interface':0 'Virus TI':1
aconnect 'QUNEO' 'Virus TI':1"
}
fACN_SAVEFILE () { # guarda un fichero con las conexiones actuales aconnect
fREAD_ARRPORTS
# fFCN_WRITEPROTECT 'off'
_bold && echo  "$tx_svcnx" && _norm
if [[ -z $1 ]]; then
	savedconnexions="${aconsvdfiles[0]}"
	read -n 1 -p "$tx_svpos" fichern
	case $fichern in # comprobar si el primer caracter de la respuesta coincide
		[0]) fFCN_SAVENEW;;
		[1]) savedconnexions="${aconsvdfiles[1]}";;
		[2]) savedconnexions="${aconsvdfiles[2]}";;
		[3]) savedconnexions="${aconsvdfiles[3]}";;
	esac
else
	savedconnexions="${aconsvdfiles[$1]}"
fi
echo > "$savedconnexions"
_bold && echo "  en $savedconnexions" && _norm
Puerto1=
Puerto2=
Clientes=
Clientesn=
Clientesn0=
Clienter=
puertoto=
aconout=
arrpuertoto=()
let iconnex=0
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do
	if [[ $ilinea -ge 5 ]]; then
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then
			Puerto1=${arrayline[1]}
			Puerto1=$(echo "${Puerto1//:/}")
			let icliente=$icliente+1
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then #SI ES UN NUMERO
			Puerto2=${arrayline[0]}
			puertofr="$Puerto1:$Puerto2"
		elif [[ ${arrayline[0]} == "Connecting" ]]; then
			for puertoto in ${line:15}
			do
				puertoto=$(echo "${puertoto//,/}")
				puertoto=$(echo "${puertoto//'[ex]'/}")
				arrpuertoto+=("$puertoto")
			done

			for i in "${!arrPuerto[@]}";
			do
				if [[ "${arrPuerto[$i]}" == "$puertofr" ]];
				then
					Clientes="${arrCliente[$i]}" && Clientesn="$i"
				fi
			done

			for i in "${!arrPuerto[@]}";
			do
				for y in "${!arrpuertoto[@]}";
				do
					if [[ "${arrPuerto[$i]}" == "${arrpuertoto[$y]}" ]];
					then
						Clienter="${arrCliente[$i]}" && Clientern="$i"
						Clienterpt="${arrPuerto[$i]}"
						puertox2=$(echo "${Clienterpt//*:/}")
						let iconnex=$iconnex+1
						[[ $iconnex == 1 ]] && echo && echo $tx_svd
						echo  "aconnect "\'"$Clientes"\'":$Puerto2 "\'"$Clienter"\'":$puertox2"
						echo  "aconnect "\'"$Clientes"\'":$Puerto2 "\'"$Clienter"\'":$puertox2" >> "$savedconnexions"
						aconout="$aconout
aconnect '$Clientes':$Puerto2 '$Clienter':$puertox2"
					
					fi
				done
			done
		fi
	fi
	let ilinea=$ilinea+1
puertoto=
arrpuertoto=()
done <<< `aconnect -l`
# fFCN_WRITEPROTECT 'on'
}
fACN_LOADFILE () { # carga el fichero con conexiones aconnect
savedconnexions="$1"
_bold && echo "$tx_ldcnx $savedconnexions" && _norm
aconnect -x
source "$savedconnexions"
aconout=$(<"$savedconnexions")
aconout="${aconout//$'\n'/ }"
_bold && echo "$aconout" && _norm
}
fACN_SEECNX () {
if [[ "$aconout" == '' ]]; then
	echo "$tx_erraconf"
else
	_bold && echo "$tx_seeacon" && _norm
	echo "$aconout"
fi
}
fACN_START () { 
if [[ "$aconout" == '' ]]; then
	echo "$tx_erraconf"
else
	_bold && echo "$aconout" && _norm
	echo "$aconout" | bash
fi
}

# midish*****************************************************************************************************
fMSH_HEADER () {
clear
_bold
echo "ramiho >> Midish front-end
********************************************************************
     +     Iniciar conexiones midish
     -     Desconectar todo
     *     Ver conexión en memoria
     .     Cargar conexión en memoria
     0     Guardar memoria a fichero
	 
     1     Cargar conexiones midish (1)
     2     Cargar conexiones midish (2)
     3     Cargar conexiones midish (3)
	 
     4     memoria: actualizar lista de dispositivos
     5     memoria: añadir conexiones / ruteos
     6     memoria: añadir trasposición

     7     memoria: añadir ajuste velocidad
     8     memoria: añadir Program Change
     9     Ver esta ayuda
     /     Volver a ramiho
********************************************************************"
_norm
}
fMSH_ACT () {
if [[ $1 != "" ]]; then  # si no (vacio)=ENTER
	if [[ $1 = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		echo
		case $1 in  
			[*]) fMSH_SEECNX;; 
			[.]) fMSH_START;;
			[0]) fMSH_SAVEFILE;; 
			[1]) fMSH_LOADFILE "${midishsvdfiles[1]}";; 
			[2]) fMSH_LOADFILE "${midishsvdfiles[2]}";;  
			[3]) fMSH_LOADFILE "${midishsvdfiles[3]}";;  
			[4]) fMSH_ADDDEV;;  
			[5]) fMSH_ADDCNX;; 
			[6]) fMSH_ADDTPS;;   
			[7]) fMSH_ADDVEL;; 
			[8]) fMSH_ADDPCH;;   
			[9]) fMSH_HEADER;;    
			[+]) fMSH_NEWCNX;; 
			[-]) fMSH_DEL; fCNX_DISCONNECTALL;; 
			*) ci_err1=true;;
		esac
	fi
else
	fMSH_START
# [[ $ci_err1 == true ]] && echo $tx_errsel && echo "Error, no setup selected" | $tts > /dev/null 2>&1 &
fi
}
fMSH_FRONT () {
lpbrk=
setup=
ci_err1=false
ci_err2=false
[[ $soundon == 'true' ]] && echo "midish front end" | $tts > /dev/null 2>&1 &
fMSH_HEADER
while true; do
	_bold
	_amarillo
	read -n 1 -p $tx_mdshprompt setup 
	read -t 0.01 resto
	[[ $setup == '/' ]] && echo "$tx_retrmh" && break
	_norm
	fMSH_ACT "$setup"
	[[ $lpbrk == 'true' ]] && break 
done

}
fMSH_NEWCNX () { 
_bold && echo $tx_midishfront && _norm
echo $tx_midishfr2
echo
fMSH_INPUT
if [[ $ci_err == 'false' ]]; then
	fMSH_START
fi
}
fMSH_SEECNX () {
if [[ "$midishout" == '' ]]; then
	echo "$tx_errmdshf"
else
	_bold && echo "$tx_seemdsh" && _norm
	echo "$midishout"
fi
}
fMSH_INPUT () { #utilidad para recibir input de puertos y canales para operar con midish
fLST_PORTS
fMSH_DEL  > /dev/null 2>&1 &
midishout=
puertos=
puertor=
canalS=()
canalR=()
portS=()
portR=()
pSalida=
pRecep=
ci_err=false
let icontN=0
let icontS=1
let icontR=1
let icontC=0
for i in "${!arrCliente[@]}"; # por cada puerto MIDI existente (arrCliente en lugar de arrPuerto)
do
	if [[ $icontN -gt 0 ]]; then
		midishout="$midishout
 dnew $icontN \"${arrCliente[$i]}\" rw"
	fi
	let icontN=$icontN+1
done
if [[ $ci_err == false ]]; then
	midishout="$midishout
 fnew midishfilter"
	_bold && echo && echo "$tx_mdshcnxhd" && _norm
	while [[ $ci_err == false ]]; do
		[[ $soundon == 'true' ]] && echo "Connect input and export clients" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshcnxin" mdevin
		if [[ $mdevin == '' ]] && [[ $icontC -gt 0 ]]; then
			tput cuu 1
			tput el 1
			break 2
		elif [[ $mdevin =~ ^-?[0-9]+$ ]]; then
			[[ $soundon == 'true' ]] && echo "Enter midi channel" | $tts > /dev/null 2>&1 &
			read -p "$tx_mdshchin> " mchin
			# echo
			if [[ $mchin == '' ]]; then
				mchin=any
			elif [[ $mchin =~ ^-?[0-9]+$ ]] && [[ $mchin -gt 0 ]] && [[ $mchin -le 16 ]]; then
				let mchin=$mchin-1
			else
				ci_err=true
			fi
			read -p "$tx_mdshcnxout" mdevout
			if [[ $mdevout =~ ^-?[0-9]+$ ]]; then

				if [[ $mchin == 'any' ]]; then
					mdcin=$mdevin
					mdcout=$mdevout
				else
					read -p "$tx_mdshchout > " mchout
					# echo
					if [[ $mchout == '' ]]; then
						mchout=any
					elif [[ $mchout =~ ^-?[0-9]+$ ]] && [[ $mchout -gt 0 ]] && [[ $mchout -le 16 ]]; then
						let mchout=$mchout-1
					else
						ci_err=true
					fi
					mdcin="{$mdevin $mchin}"
					mdcout="{$mdevout $mchout}"
				fi
			
				midishout="$midishout
 fmap {any $mdcin} {any $mdcout}"
				read -p "$tx_mdshtrans" mtrout
				if [[ $mtrout != 0 ]] && [[ $mtrout != '' ]]; then
					[[ $mtrout -le 0 ]] && mtrout="($mtrout)"
					midishout="$midishout
 ftransp {note $mdcout} $mtrout"
				fi
			else
				ci_err=true
			fi
		else
			ci_err=true
		fi

		let icontC=$icontC+1
	done	
fi
if [[ $ci_err == true ]]; then
	_bold && echo && echo "$tx_errprt" && _norm
	midishout=
else
	midishout="$midishout
i"
fi
}
fMSH_SAVEFILE () { # guarda un fichero con las conexiones actuales
error=false
if [[ "$midishout" == '' ]]; then
	echo "$tx_errmdshf"
	break
else
	_bold && echo  "$tx_svcnx" && _norm
	if [[ -z $1 ]]; then
		savedconnexions="${midishsvdfiles[0]}"
		read -n 1 -p "$tx_svpos" fichern
		case $fichern in # uno de los tres ficheros midish
			[0]) fFCN_SAVENEW;;
			[1]) savedconnexions="${midishsvdfiles[1]}";;
			[2]) savedconnexions="${midishsvdfiles[2]}";;
			[3]) savedconnexions="${midishsvdfiles[3]}";;
			*) error=true
		esac
	else
		savedconnexions="${midishsvdfiles[$1]}"
	fi
	if [[ $error == false ]]; then
		echo "$midishout" > "$savedconnexions"
		echo
		echo "$tx_mdshsvd $savedconnexions"
	else
		echo "$tx_errprt"
	fi
fi
}
fMSH_LOADFILE () { # carga el fichero con las conexiones guardadas
savedconnexions="$1"
fMSH_DEL > /dev/null 2>&1 &
_bold && echo "$tx_ldcnx $savedconnexions" && _norm
if [[ -f "$savedconnexions" ]]; then
	midishout=$(<"$savedconnexions")
	_norm
	fMSH_START
else
	echo "$tx_errmdshf"
fi
}
fMSH_ADDCNX () {
ci_err=false
fLST_PORTS
_bold && echo && echo "$tx_mdshcnxhd" && _norm
while [[ $ci_err == false ]]; do
	[[ $soundon == 'true' ]] && echo "Connect input and export clients" | $tts > /dev/null 2>&1 &
	read -p "$tx_mdshcnxin" mdevin
	if [[ $mdevin == '' ]] && [[ $icontC -gt 0 ]]; then
		tput cuu 1
		tput el 1
		break 2
	elif [[ $mdevin =~ ^-?[0-9]+$ ]]; then
		[[ $soundon == 'true' ]] && echo "Enter midi channel" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshchin> " mchin
		if [[ $mchin == '' ]]; then
			mchin=any
		elif [[ $mchin =~ ^-?[0-9]+$ ]] && [[ $mchin -gt 0 ]] && [[ $mchin -le 16 ]]; then
			let mchin=$mchin-1
		else
			ci_err=true
		fi
		read -p "$tx_mdshcnxout" mdevout
		if [[ $mdevout =~ ^-?[0-9]+$ ]]; then

			if [[ $mchin == 'any' ]]; then
				mdcin=$mdevin
				mdcout=$mdevout
			else
				read -p "$tx_mdshchout > " mchout
				if [[ $mchout == '' ]]; then
					mchout=any
				elif [[ $mchout =~ ^-?[0-9]+$ ]] && [[ $mchout -gt 0 ]] && [[ $mchout -le 16 ]]; then
					let mchout=$mchout-1
				else
					ci_err=true
				fi
				mdcin="{$mdevin $mchin}"
				mdcout="{$mdevout $mchout}"
			fi
			midishout="$midishout
fmap {any $mdcin} {any $mdcout}"
		else
			ci_err=true
		fi
	else
		ci_err=true
	fi

	let icontC=$icontC+1
done	
echo
echo "$midishout"
}
fMSH_ADDTPS () {
ci_err=false
fLST_PORTS
_bold && echo && echo "$tx_mdshtrphd" && _norm
while [[ $ci_err == false ]]; do
	[[ $soundon == 'true' ]] && echo "Transpose output" | $tts > /dev/null 2>&1 &
	read -p "$tx_mdshdevout" mdevout
	if [[ $mdevout == '' ]] && [[ $icontC -gt 0 ]]; then
		tput cuu 1
		tput el 1
		break 2
	elif [[ $mdevout =~ ^-?[0-9]+$ ]]; then
		[[ $soundon == 'true' ]] && echo "Enter midi channel" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshchout> " mchout
		# echo
		if [[ $mchout == '' ]]; then
			mchout=any
		elif [[ $mchout =~ ^-?[0-9]+$ ]] && [[ $mchout -gt 0 ]] && [[ $mchout -le 16 ]]; then
			let mchout=$mchout-1
		else
			ci_err=true
		fi
		mdcout="{$mdevout $mchout}"
		read -p "$tx_mdshtrans" mtrout
		if [[ $mtrout != 0 ]] && [[ $mtrout != '' ]]; then
			[[ $mtrout -le 0 ]] && mtrout="($mtrout)"
			midishout="$midishout
ftransp {note $mdcout} $mtrout"
			
		fi
	else
		ci_err=true
	fi

	let icontC=$icontC+1
done
echo
echo "$midishout"
}
fMSH_ADDVEL () {
ci_err=false
fLST_PORTS
_bold && echo && echo "$tx_mdshvelhd" && _norm
while [[ $ci_err == false ]]; do
	[[ $soundon == 'true' ]] && echo "Adjust output velocity" | $tts > /dev/null 2>&1 &
	read -p "$tx_mdshdevout" mdevout
	if [[ $mdevout == '' ]] && [[ $icontC -gt 0 ]]; then
		tput cuu 1
		tput el 1
		break 2
	elif [[ $mdevout =~ ^-?[0-9]+$ ]]; then
		[[ $soundon == 'true' ]] && echo "Enter midi channel" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshchout> " mchout
		# echo
		if [[ $mchout == '' ]]; then
			mchout=any
		elif [[ $mchout =~ ^-?[0-9]+$ ]] && [[ $mchout -gt 0 ]] && [[ $mchout -le 16 ]]; then
			let mchout=$mchout-1
		else
			ci_err=true
		fi
		mdcout="{$mdevout $mchout}"
		read -p "$tx_mdshveladj" mveladj
		if [[ $mveladj != 0 ]] && [[ $mveladj != '' ]]; then
			[[ $mveladj -le 0 ]] && mveladj="($mveladj)"
			midishout="$midishout
fvcurve {note $mdcout} $mveladj"
		fi
		else
			ci_err=true
		fi
	let icontC=$icontC+1
done
echo
echo "$midishout"	
}
fMSH_ADDPCH () {
ci_err=false
fLST_PORTS
_bold && echo && echo "$tx_mdshpchhd" && _norm
while [[ $ci_err == false ]]; do
	[[ $soundon == 'true' ]] && echo "Add program change" | $tts > /dev/null 2>&1 &
	read -p "$tx_mdshdevout" mdevout
	if [[ $mdevout == '' ]] && [[ $icontC -gt 0 ]]; then
		tput cuu 1
		tput el 1
		break 2
	elif [[ $mdevout =~ ^-?[0-9]+$ ]]; then
		[[ $soundon == 'true' ]] && echo "Enter midi channel" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshchout> " mchout
		# echo
		if [[ $mchout == '' ]]; then
			mchout=any
		elif [[ $mchout =~ ^-?[0-9]+$ ]] && [[ $mchout -gt 0 ]] && [[ $mchout -le 16 ]]; then
			let mchout=$mchout-1
		else
			ci_err=true
		fi
		mdcout="{$mdevout $mchout}"
		read -p "$tx_mdshpgchg" mpgchng
		if [[ $mpgchng != 0 ]] && [[ $mpgchng != '' ]]; then
			[[ $mpgchng -le 0 ]] && mpgchng="($mpgchng)"
			midishout="$midishout
co $mdcout
oaddev {pc $mdcout $mpgchng}"
		fi
	else
		ci_err=true
	fi

	let icontC=$icontC+1
done	
echo
echo "$midishout"
}
fMSH_ADDDEV () {
fREAD_ARRPORTS
echo
echo "$tx_mdshpdevup"
let icontN=0
midishdev=
for i in "${!arrCliente[@]}"; # por cada puerto MIDI existente (arrCliente en lugar de arrPuerto)
do
	[[ $icontN -eq 1 ]] && midishdev="dnew $icontN \"${arrCliente[$i]}\" rw"
	if [[ $icontN -gt 1 ]]; then
		midishdev="$midishdev
dnew $icontN \"${arrCliente[$i]}\" rw"
	fi
	let icontN=$icontN+1
done
midishout=$(echo "$midishout" | sed '/dnew/d')
midishout="$midishdev
$midishout"
echo "$midishout"
}
fMSH_DEL () { 
_bold && echo "$tx_mdshdel" && _norm
midishout=
echo s | midish -b > /dev/null 2>&1 &
echo fdel | midish -b > /dev/null 2>&1 &
echo freset | midish -b > /dev/null 2>&1 &
}
fMSH_START () { 
if [[ "$midishout" == '' ]]; then
	echo "$tx_errmdshf"
else
	_bold && echo "$tx_mdshsnd 
$midishout" && _norm
	[[ $soundon == 'true' ]] && echo "Start midish " | $tts > /dev/null 2>&1 &
	echo "$midishout
i" | midish -b > /dev/null &
	mshpid=$!
	sleep 1
	_bold
	read -p "Cualquier tecla para cerrar conexión
>"
	_norm
	kill -SIGTERM $mshpid  > /dev/null 2>&1 &
	[[ $soundon == 'true' ]] && echo "midish stopped" | $tts > /dev/null 2>&1 &
fi
}

# UTILIDADES****************************************************************************************
fREAD_ARRPORTS () { # genera unos arrays con la lista de puertos y nombres de los clientes conectados
puerto1=
puerto2=
puertoc=
arrPuerto=()
arrCliente=()
arrClienteN=()
arrPuerto+=('')
arrCliente+=('')
arrClienteN+=('')
let totpuertos=0
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 5 ]]; then # nos saltamos las cuatro primeras
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then # si la línea comienza con client
			puerto1=${arrayline[1]}
			puerto1=$(echo "${puerto1//:/}")
			nombrepuerto="${arrayline[@]:2}"
			nombrepuerto=$(echo "${nombrepuerto//' ['*/}")
			nombrepuerto=$(echo "${nombrepuerto//\'/}")
			
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then # si la línea comienza con un número
			puerto2=${arrayline[0]}
			puertoc="$puerto1:$puerto2" # puerto de envío en formato 14:0
			arrPuerto+=("$puertoc")
			arrCliente+=("$nombrepuerto")
			if [[ "$puerto2" == '0' ]]; then
				arrClienteN+=("$nombrepuerto")
			else
				arrClienteN+=("$nombrepuerto:$puerto2")
			fi
			let totpuertos=$totpuertos+1
		fi
	fi
	let ilinea=$ilinea+1
done <<< `aconnect -l`
}
fREAD_ARRCON () { 
fREAD_ARRPORTS
Puerto1=
Puerto2=
Clientes=
Clientesp=
Clientesn=
Clientesn0=
Clienter=
aClienterp=()
puertoto=
aconenviop=()
aconenvionu=()
aconenviono=()
aconrecepp=()
aconrecepnu=()
aconrecepno=()
let iconnex=0
let ilinea=0
				# aconenviop+=''
				# aconenvionu+=''
				# aconenviono+=''
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 5 ]]; then # nos saltamos las cuatro primeras
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then # si la línea comienza con client
			Puerto1=${arrayline[1]}
			Puerto1=$(echo "${Puerto1//:/}")
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then # si la línea comienza con un número
			Puerto2=${arrayline[0]}
			Clientesp="$Puerto1:$Puerto2" # puerto de envío en formato 14:0
				for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
				do
					if [[ "${arrPuerto[$i]}" == "$Clientesp" ]]; # si es el puerto de envío, recuperamos su nombre y N
					then
						Clientes="${arrCliente[$i]}" && Clientesn="$i"
					fi
				done
				aconenviop+=("$Clientesp")
				aconenvionu+=("$Clientesn")
				aconenviono+=("$Clientes")
				aconrecepp+=('')
				aconrecepnu+=('')
				aconrecepno+=('')
		elif [[ ${arrayline[0]} == "Connecting" ]]; then # si la línea comienza con Connecting entonces...
			for puertoto in ${line:15}
			do
				puertoto=$(echo "${puertoto//,/}")
				puertoto=$(echo "${puertoto//'[ex]'/}")
				aClienterp+=("$puertoto") # array de puertos de recepción
			done
			for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
			do
				for y in "${!aClienterp[@]}";
				do
					if [[ "${arrPuerto[$i]}" == "${aClienterp[$y]}" ]]; # si es el puerto de destino, recuperamos su nombre y N
					then
						Clienter="${arrCliente[$i]}" && Clientern="$i"
						let iconnex=$iconnex+1
						aconenviop+=("$Clientesp")
						aconenvionu+=("$Clientesn")
						aconenviono+=("$Clientes")
						aconrecepp+=("${aClienterp[$y]}")
						aconrecepnu+=("$Clientern")
						aconrecepno+=("$Clienter")
					fi
				done
			done
		fi
	fi
	let ilinea=$ilinea+1
	puertoto=
	aClienterp=()
done <<< `aconnect -l`
}
fREAD_PORTINFO () { # utilidad para leer el puerto N que llega como argumento
fREAD_ARRPORTS
if [[ -z "$1" ]]; then
	[[ $soundon == 'true' ]] && echo "Read port's number " | $tts > /dev/null 2>&1 &
	_bold && echo "$tx_rdport" && _norm
	fLST_PORTS
	read -n 1 -p "$tx_rdportprmpt" resp
	if [[ $resp =~ ^-?[0-9]+$ ]]; then
		echo
		fREAD_PORTINFO $resp
	else
		echo
	fi
else
	if [[ -z "${arrPuerto[$1]}" ]]; then
		echo "$tx_errnpt1 $1 $tx_errnpt2"
		[[ $soundon == 'true' ]] && echo "Error. Port number $1 does not exist" | $tts > /dev/null 2>&1 &
	else
		fLST_CONNEX "$1"
	fi
fi
}
fLST_CONNEX () { # imprime la lista de conexiones
fREAD_ARRCON
puerto0=
ttstemp=
if [[ ! -z "$1" ]]; then
	# echo "t$1 ${aconenviop[$1]} ${aconenvionu[$1]}  ${aconenviono[$1]} "
	_bold && echo "     $1  ${arrCliente[$1]}   [${arrPuerto[$1]}]" && _norm
	ttstemp="device number $1. client ${arrCliente[$1]}, port ${arrPuerto[$1]}"
	if [[ "${aconrecepnu[$1]}" != '' ]]; then
		echo "            "$'\U2192'"   ${aconrecepnu[$1]}   ${aconrecepno[$1]}   [${aconrecepp[$1]}]"
		ttstemp="$ttstemp. 
Connected to client ${aconrecepno[$1]}, port ${aconrecepp[$1]}"
	fi
else
	let icontador=1
	_bold && echo "$tx_lstcnxprt " && _norm
	for i in "${!aconenviop[@]}"; 
	do
		[[ "$puerto0" != "${aconenviop[$i]}" ]] && _bold && echo "     ${aconenvionu[$i]}   ${aconenviono[$i]}   [${aconenviop[$i]}]" && _norm && ttstemp="$ttstemp. 
device number ${aconenvionu[$i]}. client ${aconenviono[$i]}, port ${aconenviop[$i]}"
		[[ "${aconrecepnu[$i]}" != '' ]] && echo "            "$'\U2192'"   ${aconrecepnu[$i]}   ${aconrecepno[$i]}   [${aconrecepp[$i]}]" && ttstemp="$ttstemp. 
Connected to client ${aconrecepno[$1]}, port ${aconrecepp[$1]}"
		let icontador=$icontador+1
		puerto0="${aconenviop[$i]}"
	done
fi
}
fLST_PORTS () { # imprime la lista de puertos
fREAD_ARRPORTS
# texrecl=
_bold && echo "$tx_lstprt" && _norm
let ipuerto=0
for i in "${arrPuerto[@]}"
do
   if [[ $ipuerto == 0 ]]; then
		_bold && echo "$tx_hdprt" && _norm
   else
		echo "     $ipuerto   $i   ${arrClienteN[$ipuerto]}"
		# texrecl=$texrecl". Device number $ipuerto. client ${arrCliente[$ipuerto]}, port ${i:0:2}, ${i:3:1}"
   fi
   let ipuerto=$ipuerto+1
done
}
fLST_USB () { # imprime la lista de dispositivos USB conectados
_bold && echo "$tx_lstusb" && _norm
lsusb
}
fLST_ALSADETAILS () {
_bold && echo "$tx_lstprt" && _norm
aplaymidi -l
echo
_bold
echo "$tx_detcnxprt"
_norm	
aconnect -l			
}
fTTS_DETAILS () {
fREAD_ARRCON
ttstmp=
# _bold
# echo "$tx_lstprt"
let icuenta=0
for i in "${!arrPuerto[@]}";
do
	[[ $i != 0 ]] && fREAD_PORTINFO $i && ttstmp="$ttstmp
$ttstemp"
done
ttstmp="$totpuertos ports with $iconnex open connexions. 
$ttstmp"
}
fTTS_HELP () { # lector con tts de la ayuda
ttstmp="Raspi Midi Host.
slash to exit.
plus to connect ports.
minus to disconnect ports.
dot to disconnect all.
0 for favorite connexions.
9 to read raspi's IP number"
}
fTTS_IP () {
if nc -zw1 google.com 443; then
	ttstmp=`hostname -I`
else
	ttstmp=`hostname -I`
	ttstmp="No internet connexion. $ttstmp"
fi
}

# CONEXIONES***********************************************************************************************
fCNX_OPS () { # entrada para las conexiones
cnxtyp=$1
cnxoper=
_bold
if [[ $cnxtyp == 'cnx' ]]; then
	echo "$tx_midicnx"
	cnxoper=''
	ttstmp="Connect two ports"
elif [[ $cnxtyp == 'dcnx' ]]; then
	echo "$tx_mididcnt"
	cnxoper='-d '
	ttstmp="Disconnect two ports"
elif [[ $cnxtyp == 'excl' ]]; then
	echo "$tx_midicnxex"
	cnxoper='-e '
	ttstmp="Connect exclusive two ports"
else
	ci_err=true
fi
[[ $soundon == 'true' ]] && echo "$ttstmp" | $tts > /dev/null 2>&1 &
fLST_CONNEX
_norm
fCNX_INPUT $2 $3
if [[ $ci_err == false ]]; then
	echo
	echo "aconnect $cnxoper $puertos $puertor"
	aconnect $cnxoper $puertos $puertor
	[[ $? != 0 ]] && echo "$tx_errcnx"
fi
}
fCNX_INPUT () { #utilidad para recibir input de índices o puertos para operar aconnect. Si se usan las FUNC se envían los índices
fREAD_ARRPORTS
puertos=
puertor=
nombres=
nombrer=
ci_err=false
ci_all=false
if [[ -z "$1" ]]; then
	_bold
	[[ $soundon == 'true' ]] && echo "Enter first port " | $tts > /dev/null 2>&1 &
	echo
	echo "$tx_cnxinp1"
	_norm
	_verde
	read -n 1 -p "$tx_cnxinppr1"  res1
	_norm
	if [[ $res1 =~ ^-?[0-9]+$ ]]; then
		if [[ $res1 -le ${#arrPuerto[@]} ]]; then
			puertos=${arrPuerto[res1]}
			nombres=${arrClienteN[res1]}
		else
			ci_err=true
		fi
	elif [[ $res1 == '*' ]]; then
		ci_all=true
	elif [[ $res1 == '' ]]; then
		ci_err=true
	elif [[ $res1 == '.' ]]; then
		read res1
		res1=$(echo "${res1//../:}")
		puertos=$res1
		# nombres=${arrClienteN[res1]}
	else # si res1 no está vacío ni empieza por un número (N) o un punto, asumimos que se están usando las FUNC del NumPad y comparamos el 3er caracter
		read -n 1 resp2 
		read -n 1 resp3
		read -t 0.01 resto
		case $resp3 in
			[4F]) let res1=1;; # End
			[B]) let res1=2;;  # Flecha Dn
			[6]) let res1=3;;  # Pg Dn / Av Pag
			[D]) let res1=4;; # Flecha Lft
			[EG]) let res1=5;; # (5) en el centro de las flechas
			[C]) let res1=6;; # Flecha Rgt
			[1H]) let res1=7;; # Home
			[A]) let res1=8;; # Flecha Up
			[5]) let res1=9;;  # Pg Up / Re Pag
			*) ci_err=true;;
		esac
		if [[ $res1 =~ ^-?[0-9]+$ ]]; then
			puertos=${arrPuerto[res1]}
			nombres=${arrClienteN[res1]}
		else
			ci_err=true
			res1=
		fi
	fi
	if [[ $ci_err == false ]]; then
		[[ $soundon == 'true' ]] && echo "Enter second port" | $tts > /dev/null 2>&1 &
		echo
		_verde
		read -n 1 -p "$tx_cnxinppr2" res2
		_norm
		if [[ $ci_all == 'true' ]]; then
			if [[ $res2 == '*' ]] || [[ $res2 == '' ]]; then
				if [[ $cnxtyp == 'cnx' ]]; then
					fCNX_CONNECTALL
				else
					fCNX_DISCONNECTALL
				fi
			else
				fCNX_ALL2PRT $res2
				ci_err=true
			fi
		elif [[ $res2 == '*' ]]; then
			fCNX_PRT2ALL $res1
			ci_all=true
			ci_err=true
		elif [[ $res2 =~ ^-?[0-9]+$ ]]; then
			if [[ $res1 -le ${#arrPuerto[@]} ]]; then
				puertor=${arrPuerto[res2]}
				nombrer=${arrClienteN[res2]}
			else
				ci_err=true
			fi
		elif [[ $res2 == '' ]]; then
			ci_err=true
			echo "Error"
		elif [[ $res2 == '.' ]]; then
			read res2
			res2=$(echo "${res2//../:}")
			puertor=$res2
			nombrer=${arrClienteN[res2]}
		else
			read -n 1 resp2 # se guardan los primeros tres caracteres de la respuesta para buscar equivalencias
			read -n 1 resp3
			read -t 0.01 resto
			case $resp3 in
				[4F]) let res2=1;; # End
				[B]) let res2=2;;  # Flecha Dn
				[6]) let res2=3;;  # Pg Dn / Av Pag
				[D]) let res2=4;; # Flecha Lft
				[EG]) let res2=5;; # (5) en el centro de las flechas
				[C]) let res2=6;; # Flecha Rgt
				[1H]) let res2=7;; # Home
				[A]) let res2=8;; # Flecha Up
				[5]) let res2=9;;  # Pg Up / Re Pag
				*) ci_err=true;;
			esac
			if [[ $res2 =~ ^-?[0-9]+$ ]]; then
				puertor=${arrPuerto[res2]}
				nombrer=${arrClienteN[res2]}
			else
				ci_err=true
				res2=
			fi
		fi
	fi
else
	if [[ $1 == 'simball' ]]; then
		if [[ $2 == 'simball' ]] || [[ $2 == '' ]]; then
			if [[ $cnxtyp == 'cnx' ]]; then
				fCNX_CONNECTALL
			elif [[ $cnxtyp == 'dcnx' ]]; then
				fCNX_DISCONNECTALL
			fi
		else
			fCNX_ALL2PRT $2
		fi
	elif [[ $2 == 'simball' ]]; then
		fCNX_PRT2ALL $1
	else
		puertos=${arrPuerto[$1]}
		nombres=${arrClienteN[$1]}
		puertor=${arrPuerto[$2]}
		nombrer=${arrClienteN[$2]}
	fi
fi
if [[ $ci_err == true ]] && [[ $ci_all == false ]]; then
	_bold && echo && echo "$tx_errprt" && _norm
fi
}
fCNX_PRT2ALL () {
indpuertos="$1"
ci_err=true
ci_all=true
_bold && echo && echo "$tx_prt2allhd" && _norm
for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
do
	if [[ $i -ge 1 ]] && [[ $i != $indpuertos ]]; then
		puertos=${arrPuerto[$indpuertos]}
		nombres=${arrClienteN[$indpuertos]}
		puertor=${arrPuerto[$i]}
		nombrer=${arrClienteN[$i]}
		aconnect $cnxoper $puertos $puertor 2>/dev/null
	fi
done
}
fCNX_ALL2PRT () {
indpuertor="$1"
ci_err=true
ci_all=true
_bold && echo && echo "$tx_all2prthd" && _norm
for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
do
	if [[ $i -ge 1 ]] && [[ $i != $indpuertor ]]; then
		puertos=${arrPuerto[$i]}
		nombres=${arrClienteN[$i]}
		puertor=${arrPuerto[$indpuertor]}
		nombrer=${arrClienteN[$indpuertor]}
		aconnect $cnxoper $puertos $puertor 2>/dev/null
	fi
done
}
fCNX_CONNECTALL() { # conectar todos los puertos MIDI entre si
fREAD_ARRPORTS
connectall=true
arrConPE=()
arrConPR=()
arrConCE=()
arrConCR=()
let icuentax=0
let icuentay=0
ttstmp="Connect all devices with each other"
aconnect -x
_bold && echo "$tx_cnctall" && echo && _norm
for i in "${arrPuerto[@]}"
do
	for n in "${arrPuerto[@]}"
	do
		if [[ "$i" != "$n" ]] && [[ "${arrCliente[icuentax]}" != "${arrCliente[icuentay]}" ]] && [[ $icuentax -ge 1 ]] && [[ $icuentay -ge 1 ]]; then 
			aconnect $i $n 
				if [[ $? == 0 ]]; then 
					arrConPE+=("$i") && arrConPR+=("$n") && arrConCE+=("${arrCliente[icuentax]}") && arrConCR+=("${arrCliente[icuentay]}")
				else
					echo Error en el intento de conectar ${arrCliente[icuentax]} -> ${arrCliente[icuentay]}
				fi
		fi
	let icuentay=$icuentay+1
	done
	let icuentay=0
	let icuentax=$icuentax+1
done
}
fCNX_DISCONNECTALL () { # desconectar todos los puertos MIDI entre si
ttstmp="Close all connexions"
connectall=false
_bold && echo && echo "$tx_clsall" && _norm
aconnect -x
}

# MONITOR*MIDI**************************************************
fMON_FRONT () { # interface del monitor de puertos MIDI
let montipnum=1
let iportout=1
fMON_LISTPORT
montipo=${arrtipomonitor[$montipnum]}
devicename=${arrClienteN[$iportout]}
tout="monitor $devicename $montipo"
while true; do
	errorc=
	clear
	_norm
	fMON_LISTPORT
	_bold
	echo '*******************************************************'
	echo
	echo "$tx_monfrhd [${arrPuerto[$iportout]}] ${arrCliente[$iportout]} ($montipo)"
	if [[ $send == true ]]; then
		send=false
		if [[ $montipo == 'aseqdump' ]]; then
			fMON_ASEQ $iportout
		else
			fMON_RM $montipo
		fi
	fi
	_amarillo
	read -s -n 1 -p "$tx_monprompt" resp
	read -n 1 -t 0.05 caracter2
	read -n 1 -t 0.01 caracter3
	read -t 0.01 resto
	# echo -en "\r\033[K" # borra la línea anterior (prompt de read y respuesta)
	_norm
	_blanco
	if [[ $resp == '' ]]; then
		send=true
		tout="monitor $devicename $montipo"
	elif [[ $resp = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		case $resp in # comprobar si el primer caracter de la respuesta coincide
			[/q]) echo "$tx_retrmh"
				break;;
			[9]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum-1
				[[ $montipnum -eq 0 ]] && let montipnum=9
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";;
			[3]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum+1
				[[ $montipnum -eq 10 ]] && let montipnum=1
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";;
			[2]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrCliente[@]} ]] && let iportout=$iportout-1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};;
			[8]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};;
			*) #si no se encuentran coincidencias para $resp
				errorc=true;;
		esac
		case $caracter3 in # para usar con flechas
			[6]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum-1
				[[ $montipnum -eq 0 ]] && let montipnum=9
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";; # Flecha Lft
			[5]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum+1
				[[ $montipnum -eq 10 ]] && let montipnum=1
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";; # Flecha Rgt
			[B]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrCliente[@]} ]] && let iportout=$iportout-1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};;  # Flecha Dn¡
			[A]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};; # Flecha Up
			*) ci_err2=true;;
		esac
		[[ $ci_err2 == true ]] && echo $tx_errsel && [[ $soundon == 'true' ]] && echo "Error on selection" | $tts > /dev/null 2>&1 &
	fi
done
}
fMON_ARRTYP () {
arrtipomonitor=()
arrtipomonitor+=("aseqdump")
arrtipomonitor+=("aseqdump")
arrtipomonitor+=("note")
arrtipomonitor+=("cc")
arrtipomonitor+=("start stop cont")
arrtipomonitor+=("pc")
arrtipomonitor+=("syx")
arrtipomonitor+=("rpn")
arrtipomonitor+=("sr")
arrtipomonitor+=("sc")
}
fMON_LISTPORT () {
fREAD_ARRPORTS
_bold
echo "$tx_monheader"
echo "$tx_arrtyphd"
_norm
let icontador=0
for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
do
	if [[ $icontador == 0 ]]; then
		_bold
		echo "$tx_arrtphd2"
		_norm
	elif [[ $icontador -eq $iportout ]]; then
		_bold
		echo " X   $icontador    [${arrPuerto[$icontador]}]   ${arrCliente[$icontador]} "
		_norm
	else
		echo "     $icontador    [${arrPuerto[$icontador]}]   ${arrCliente[$icontador]}  "

	fi
	let icontador=$icontador+1
done
let icontador=0
echo
_bold
echo "$tx_arrtphd3"
_norm
TAB="$(printf '\t')"
while IFS= read -r line; do # por cada puerto MIDI existente
	if [[ $icontador -eq 0 ]]; then
		_bold
		echo "Sel   Monitores"
		_norm
	elif [[ $icontador -eq $montipnum ]]; then
		_bold
		echo " ->  $icontador    $line"
		_norm
	else
		echo "     $icontador    $line"
	fi
	let icontador=$icontador+1
done <<< "$tx_montyp"
}
fMON_ASEQ () { # monitor MIDI usando aseqdump
puertom=${arrPuerto[$1]}
if [[ $devicename == '' ]]; then
	devicename=${arrClienteN[$1]}
fi
if [[ $puertom != '' ]]; then
	echo 
	echo aseqdump -p $puertom
	aseqdump -p $puertom &
	PID=$!
	echo
	echo "Monitor de $devicename ($PID)"
	sleep 1
	_bold
	echo "$tx_anyky" # se cancela la monitorización tocando cualquier tecla
	_norm
	read -n 1 resto
		echo 
		echo "$tx_mondeac $devicename ($PID)"
		kill -INT $PID && PID=
else
	echo
	echo "$tx_errcli" 
fi
}
fMON_RM () { # monitor MIDI usando receivemidi
tipomonit=$1
puertom=${arrPuerto[$iportout]}
clientem=${arrClienteN[npm]}
_bold && echo "$tx_monhd2" && echo && _norm
if [[ $puertom != '' ]]; then
	echo 
	echo receivemidi dev $devicename $tipomonit
	_bold
	echo $tx_ctlc
	_norm
	echo
	$receivemidi dev $devicename $tipomonit
	echo
else
	echo
	echo "$tx_errcli"
fi

}
fMON_ARRTYP

# SEND*MIDI***********************************************************
fSM_FRONT () { # enviar señal midi a los puertos con sendmidi
let iportout=1
let smch=1
let smoct=0
let smnot=48
let iportout0=0
let smch0=1
let smoct0=3
let smnot0=48
send=false
devicename=
clienttyp='dev'
clienttypout=
fSM_LISTPORT
devicename=${arrClienteSM[$iportout]}
tout="sendmidi $clienttyp $devicename ch $smch on $smnot 127 clock 120 off $smnot 127"
while true; do
	errorc=
	clear
	_bold && echo "$tx_smhdr " && _norm
	fSM_LISTPORT
	echo
	echo "$tout"
	[[ $send == true ]] && send=false && $("$sendmidi" $clienttyp "$devicename" ch $smch on $smnot 127 clock 120 off $smnot 127)
	_bold
	_amarillo
	read -s -n 1 -p "$tx_smprompt" resp
	read -n 1 -t 0.05 caracter2
	read -n 1 -t 0.01 caracter3
	read -t 0.01 resto
	_norm
	# echo -en "\r\033[K" # borra la línea anterior (prompt de read y respuesta)
	_norm
	_blanco
	if [[ $resp == '' ]]; then
		send=true
		tout="sendmidi $clienttyp $devicename ch $smch on $smnot 127 clock 120 off $smnot 127"
	elif [[ $resp = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		case $resp in # comprobar si el primer caracter de la respuesta coincide
			[/q]) echo "$tx_retrmh"
				break;;
			[5]) tout="Mandar secuencia"
				x=$("$sendmidi" $clienttyp $devicename ch $smch file "$midiseq" );;
			[0..]) echo "Panic!"
				x=$("$sendmidi" $clienttyp $devicename panic) ;;
			[1]) if [[ $clienttyp == 'dev' ]]; then
					clienttyp='virt'
					clienttypout='[vir]'
				else
					clienttyp='dev'
					clienttypout=
				fi
				tout="Tipo de cliente $clienttyp";;
			[7]) let smch=1
				let smoct=0
				let smnot=48
				tout="Cargar valores por defecto";;
			[+]) let smnot0=$smnot
				let smnot=$smnot+1
				[[ $smnot -ge 128 ]] && let smnot=127
				tout="Nota $smnot0 > $smnot";;
			[-]) let smnot0=$smnot
				let smnot=$smnot-1
				[[ $smnot -le 0 ]] && let smnot=0
				tout="Nota $smnot0 > $smnot";;
			[8]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]}
				;;
			[2]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrClienteSM[@]} ]] && let iportout=$iportout-1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]}
				;;
			[3]) let smoct=-1
				let smnot0=$smnot
				let smnot=$smnot+$smoct*12
				[[ $smnot -ge 128 ]] && let smnot=127
				tout="(-Oct) Nota $smnot0 > $smnot"
				let smoct=0;; 
			[9]) let smoct=1
				let smnot0=$smnot
				let smnot=$smnot+$smoct*12
				[[ $smnot -ge 128 ]] && let smnot=127
				tout="(+Oct) Nota $smnot0 > $smnot"
				let smoct=0;;
			[4]) let smch0=$smch
				let smch=$smch-1
				[[ $smch -eq 0 ]] && let smch=16
				echo "Canal MIDI $smch0 > $smch";;
			[6]) let smch0=$smch
				let smch=$smch+1
				[[ $smch -eq 17 ]] && let smch=1
				tout="Canal MIDI $smch0 > $smch";;
			*) #si no se encuentran coincidencias para $resp
				errorc=true;;
		esac
		case $caracter3 in # para usar con flechas
			[B]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrClienteSM[@]} ]] && let iportout=$iportout-1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]};;  # Flecha Dn¡
			[D]) let smch0=$smch
				let smch=$smch-1
				[[ $smch -eq 0 ]] && let smch=16
				echo "Canal MIDI $smch0 > $smch";; # Flecha Lft
			[C]) let smch0=$smch
				let smch=$smch+1
				[[ $smch -eq 17 ]] && let smch=1
				tout="Canal MIDI $smch0 > $smch";; # Flecha Rgt
			[A]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]};; # Flecha Up
			*)	#si no se encuentran coincidencias para $resp
				errorc=true;;
		esac
	fi
done
}
fSM_LISTPORT () {
fSM_READARRPORTS
let icontador=0
for i in "${!arrClienteSM[@]}"; # por cada puerto MIDI existente
do
	if [[ $icontador == 0 ]]; then
		_bold
		echo "$tx_lstprthd"
		_norm
	elif [[ $icontador -eq $iportout ]]; then
		_bold
		echo " X   $icontador    ${arrClienteSM[$icontador]}    ch$smch    n$smnot"
		_norm

	else
		echo  "     $icontador    ${arrClienteSM[$icontador]}  "

	fi
	let icontador=$icontador+1
done
}
fSM_READARRPORTS () { # genera unos arrays con la lista de puertos y nombres de los clientes conectados
arrClienteSM=()
arrClienteSM+=('')
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 1 ]]; then # nos saltamos las primera linea	
		arrClienteSM+=("$line")
	fi
	let ilinea=$ilinea+1
done <<< `$sendmidi list`
}

# RAMIHO*FRONT***********************************************************
fRMH_HEADER () { # pantalla de ayuda
_norm
_blanco
_bold	
echo "$tx_hlptermhd1"
}
fRMH_FRONT () { # loop del entorno interactivo RMH
while true; do
	errorc=
	_verde
	_bold
	read -n 1 -p "ramiho> " caracter1 # usamos el primer y tercer caracteres de la respuesta para buscar equivalencias
	read -n 1 -t 0.05 caracter2
	read -n 1 -t 0.01 caracter3
	read -t 0.01 resto
	echo
	_blanco
	if [[ $caracter1 = "" ]]; then # si borrar (Backspace) entonces
		fCNX_OPS 'excl'
		fLST_CONNEX
	else
		case $caracter1 in # comprobar si el primer caracter de la respuesta coincide
			[*]) if [[ $connectall == 'true' ]]; then
					fCNX_DISCONNECTALL
				else
					fCNX_CONNECTALL
					fLST_CONNEX
				fi;;
			[/q]) fRMH_EXIT;;
			[+]) fCNX_OPS 'cnx'
				fLST_CONNEX;; 
			[-]) fCNX_OPS 'dcnx'
				fLST_CONNEX;;
			[..,]) fCNX_DISCONNECTALL;;
			[0]) fRMH_ACT 0;;
			[1]) fRMH_ACT 1;;
			[2]) fRMH_ACT 2;;
			[3]) fRMH_ACT 3;;
			[4]) fRMH_ACT 4;;
			[5]) fRMH_ACT 5;;
			[6]) fRMH_ACT 6;;
			[7]) fRMH_ACT 7;;
			[8]) fRMH_ACT 8;;
			[9]) fRMH_ACT 9;;
			*) #si no se encuentran coincidencias para $caracter1
				errorc=true;;
		esac
		case $caracter3 in # para teclas especiales como flechas, Inicio, Fin, etc. comprobamos el tercer caracter guardado
			[2]) fCNX_CONNECTALL
				fLST_CONNEX;; # Ins
			[3]) fCNX_DISCONNECTALL;;  # Del
			[4F]) fREAD_PORTINFO 1;; # End
			[B]) fREAD_PORTINFO 2;;  # Flecha Dn
			[6]) fREAD_PORTINFO 3;;  # Pg Dn / Av Pag
			[D]) fREAD_PORTINFO 4;; # Flecha Lft
			[EG]) fREAD_PORTINFO 5;; # (5) en el centro de las flechas
			[C]) fREAD_PORTINFO 6;; # Flecha Rgt
			[1H]) fREAD_PORTINFO 7;; # Home
			[A]) fREAD_PORTINFO 8;; # Flecha Up
			[5]) fRMH_ACT 9;;  # Pg Up / Re Pag
			*)	[[ $errorc == true  ]] && echo "...";;
		esac
	fi
done
}
fRMH_ACT () {
case $1 in  
	[0]) fFCN_FRONT;; 
	[1]) if [[ $soundon == 'true' ]]; then
			fTTS_DETAILS && echo "$ttstmp" | $tts > /dev/null 2>&1 &
		else
			fLST_CONNEX
		fi;; 
	[2]) fLST_ALSADETAILS;;  
	[3]) fLST_USB;;  
	[4]) if [[ -z "$2" ]]; then
			fMON_FRONT
		else
			fREAD_ARRPORTS
			fMON_ASEQ $2
		fi;;  
	[5]) fSM_FRONT;; 
	[6]) fREAD_PORTINFO;;
	[7]) if [[ -z "$2" ]]; then
			fACN_FRONT
		else
			fACN_ACT
		fi;;
	[8]) if [[ -z "$2" ]]; then
			fMSH_FRONT
		else
			fMSH_ACT
		fi;;  
	[9]) fRMH_NUEVE;;
	[*]) if [[ $connectall == 'true' ]]; then
				fCNX_DISCONNECTALL
			else
				fCNX_CONNECTALL
				fLST_CONNEX
			fi;;     
	*) ci_err1=true;;
esac
}
fRMH_START () {
[[ $soundon == 'true' ]] && echo "Welcome to ra mi ho" | $tts > /dev/null 2>&1 &
if grep -q "aconnect" "${aconsvdfiles[0]}"; then
	fACN_LOADFILE "${aconsvdfiles[0]}" > /dev/null 2>&1
fi
midishout=$(<"${midishsvdfiles[0]}") > /dev/null 2>&1
clear
fRMH_HEADER
fLST_CONNEX
fRMH_FRONT
}
fRMH_NUEVE () {
dosnueve=
_verde
_bold
read -n 1 -t 1 -p "$tx_frshhlp" dosnueve
	_blanco
if [[ $dosnueve -eq 9 ]]; then
	clear
	fTTS_IP && echo "$ttstmp"
	fRMH_HEADER
	[[ $soundon == 'true' ]] && echo "$ttstmp" | $tts > /dev/null 2>&1 && fTTS_HELP && echo "$ttstmp" | $tts > /dev/null 2>&1 &
elif [[ $dosnueve -eq 8 ]]; then
	fCONF_MUTE 
	[[ $soundon == 'true' ]] && echo "$ttstmp" | $tts > /dev/null 2>&1 &
elif [[ $dosnueve -eq 7 ]]; then
	fCONF_LOCALE
else
	clear
	fRMH_HEADER
fi
}
fRMH_EXIT () { # menu para salir
[[ $soundon == 'true' ]] && echo "slash to exit" | $tts > /dev/null 2>&1 &
_bold
_amarillo
# tput cuu 1
read -n 1 -p "$tx_exitsl" iexit
if [[ $iexit == '/' ]]; then
	echo "$tx_exitout"
	[[ $soundon == 'true' ]] && echo "Good vibe" | $tts > /dev/null 2>&1 &
	_norm
	fACN_SAVEFILE 0 > /dev/null 2>&1
	fMSH_SAVEFILE 0 > /dev/null 2>&1
	exit 0
fi
_blanco
echo
}

# CLI
if [[ $# -ge 1 ]]; then # si se ejecutó con argumentos
	for arg in "$@"; do 
		if [[ $arg == 'mute' ]]; then
				soundon='false'
				fRMH_START
		elif [[ $arg == +* ]]; then
			pt1=
			pt2=
			if [[ ${arg:1:1} == '*' ]]; then # si no expande el * y no funciona...
				pt1='simball'
			else
				pt1=${arg:1:1}				
			fi
			if [[ ${arg:2:1} == '*' ]]; then
				pt2='simball'
			else
				pt2=${arg:2:1}				
			fi
			fCNX_OPS 'cnx' $pt1 $pt2
			fLST_CONNEX
		elif [[ $arg == -* ]]; then
			pt1=
			pt2=
			pt1=${arg:1:1}
			pt2=${arg:2:1}
			fCNX_OPS 'dcnx' "$pt1 $pt2"
			fLST_CONNEX
		elif [[ $arg == '.' ]] || [[ $arg == ',' ]]; then
			fCNX_DISCONNECTALL
			fLST_CONNEX
		elif [[ $arg == 00* ]]; then
			inumcli=${arg:2}
			if [[ -z "$inumcli" ]]; then
				fFCN_SELFILE
			else
				fFCN_SELFILE "$inumcli"
			fi		
		elif [[ $arg == 0* ]]; then
			inumcli=${arg:1}
			if [[ -z "$inumcli" ]]; then
				fFCN_FRONT
			else
				fFCN_ACT "$inumcli"
			fi		
		elif [[ $arg == 1 ]]; then
			fRMH_ACT 1
		elif [[ $arg == 2 ]]; then
			fRMH_ACT 2
		elif [[ $arg == 3 ]]; then
			fRMH_ACT 3
		elif [[ $arg == 4* ]]; then
			inumcli=${arg:1}
			fRMH_ACT 4 $inumcli
		elif [[ $arg == 5 ]]; then
			fRMH_ACT 5
		elif [[ $arg == 6* ]] || [[ $arg == '/'* ]]; then
			inumcli=${arg:1}
			fREAD_PORTINFO $inumcli
		elif [[ $arg == 7* ]]; then
			inumcli=${arg:1}
			fRMH_ACT 7 $inumcli
		elif [[ $arg == 8* ]]; then
			inumcli=${arg:1}
			fRMH_ACT 8 $inumcli
		elif [[ $arg == 99 ]]; then
			soundon='true'
			fTTS_IP
			echo "$ttstmp"
			echo "$ttstmp" | $tts > /dev/null 2>&1 &
		elif [[ $arg == 98 ]] || [[ $arg == 'speak' ]]; then
			soundon='true'
			fRMH_START
		elif [[ $arg == 97 ]]; then
			fLOCALE_ES
			fRMH_START
		elif [[ $arg == 9 ]]; then
			# wpa_cli list_networks
			# wpa_cli scan_results
			# echo "IP:"
			hostname -I
			echo "$txhlpcli"
		elif [[ -f $arg ]]; then
			fFCN_LOADFILE $arg
		fi 
	done
else # si se ejecutó sin argumentos, entrar en el loop
	fRMH_START
fi
exit 0
		
# RECURSOS
	# RASPBERRY PI AS USB/BLUETOOTH MIDI HOST
	# https://neuma.studio/rpi-midi-complete.html
	#
	# LINUX MIDI CHEATSHEET 
	# https://mclarenlabs.com/blog/2018/07/03/linux-midi-cheatsheet/
	#
	# Shell programming with bash: by example, by counter-example
	# https://matt.might.net/articles/bash-by-example/
	#
	# the ALSA system exposes many of its details through the /proc/asound filesystem
	# cat /proc/asound/seq/clients
	#
# HERRAMIENTAS / DEBUGGING TOOLS
	# CREAR puertos virtuales:
	# sudo modprobe snd-virmidi snd_index=1
	# o
	# sudo modprobe snd-virmidi enable=1,1 midi_devs=4,1
	# BORRAR los puertos virtuales:
	# sudo modprobe -r snd-virmidi
	#
	# dmesg to see messages about USB devices being plugged and unplugged. Use this if you are unsure if your equipment is being recognized by your system. The [-w] option makes dmesg wait for new messages.
	#
	# lsusb to list the USB devices currently connected to your system. Use this if you are unsure if your keyboard or controller is being recognized as a USB device.