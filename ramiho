#!/bin/bash
# ramiho - raspi midi host
# Cliente de Teclado Numérico Raspi MIDI host
# kdg/dkd - kódigo diskordia en edpanfleto.com/kdgdkd/
# LOCALE************************************************
fLOCALE_ES () {
txconf_locale="ES"
tx_localch="ramiho en castellano"
tx_sndon="con sonido"
tx_sndoff="silenciado"
tx_checkfavdev="Chequea dispositivos favoritos:"
tx_errnofavdev="  No se encontraron dispositivos favoritos conectados a ramiho"
tx_retrmh=" Volver a ramiho"
tx_errsel="Error introduciendo selección"
tx_cnx="ramiho_fav> "
tx_mdshprompt="ramiho_midish> "
tx_svcnx="  Guardar conexiones actuales"
tx_svpos="Elegir posición (1, 2 o 3)> "
tx_svd="Conexiones guardadas:"
tx_mdshsvd="Conexiones guardadas en "
tx_ldcnx="  Cargar conexiones guardadas "
tx_midishfront=" Rutear canales y puertos"
tx_midishfr2=" Definiendo puertos, canales y conexiones, déja la respuesta en blanco para pasar al siguiente"
tx_ctlc="    Ctrl + C para salir"
tx_mdshdel="9 Borrar ruteos MIDI"
tx_rdport="Leer puerto N"
tx_rdportprmpt="N del puerto> "
tx_errnpt1="     El puerto número "
tx_errnpt2=" no existe"
tx_lstcnx="Lista de conexiones"
tx_err0cnx=" ! No hay conexiones activas"
tx_lstcnxprt="Lista de puertos y conexiones"
tx_lstprt="Lista de puertos disponibles"
tx_hdprt="     N   Puerto Nombre"
tx_lstusb="Lista de dispositivos USB conectados"
tx_cnxinp1="Introduce puertos usando N del puerto o el formato .14.0"
tx_cnxinppr1="Primer puerto> "
tx_cnxinppr2="Segundo puerto> "
tx_errprt=" !! Error introduciendo puertos"
tx_midicnx="Conexión MIDI entre puertos"
tx_errcnx="Error, no se ha podido conectar"
tx_midicnxex="Conectar puertos de forma exclusiva"
tx_mididcnt="Desconectar puertos"
tx_cnctall="Conectando todos los clientes entre sí"
tx_clsall="Cerrando todas las conexiones MIDI"
tx_smprompt="ramiho_sendmidi> "
tx_monprompt="ramiho_monitor> "
tx_monfrhd="Enter para comenzar monitor de "
tx_montyp="Tipo de Monitor"
tx_monclt="Cliente "
tx_arrtyphd="Seleccionar puerto (arriba / abajo)"
tx_arrtphd2="Sel  N   [puerto]  Cliente"
tx_arrtphd3="Seleccionar tipo de monitor (RePag / AvPag)"
tx_anyky="Pulsa cualquier tecla para salir del monitor"
tx_mondeac="Desactivando monitor de "
tx_errcli="Error, no se identificó el cliente"
tx_prt2allhd="Conectar a todos los puertos"
tx_all2prthd="Conectar desde todos los puertos"
tx_monhd2="Monitor MIDI de puerto N"
tx_lstprthd="Sel  N    Cliente  [puerto]    Canal ch    Nota n"
tx_detcnxprt="ALSA Detalle de conexiones"
tx_mdshoutin="Crea dispositivos de entrada"
tx_mdshoutout="Crea dispositivos de salida"
tx_mdshprtin="N de puerto de envío "
tx_mdshchin="    Canal MIDI envío "
tx_mdshprtout="N de puerto de recepción "
tx_mdshchout="    Canal MIDI recepción "
tx_mdshlstin="Lista dispositivos de entrada"
tx_mdshlstout="Lista dispositivos de salida"
tx_mdshcnxhd="Conecta los dispositivos de entrada con los de salida"
tx_mdshcnxin="Conectar dispositivo de entrada > input"
tx_mdshcnxout="   Con dispositivo de salida > output"
tx_mdshtrans="   trasponer (st) > "
tx_mdshsnd="Enviando..."
tx_errmdshf="Define primero una conexión con midish"
tx_seemdsh="Detalles de la última conexión con midish"
tx_exitsl="  /   para salir> "
tx_exitout="  Saliendo..." 
tx_monheader='ramiho >> monitor MIDI
*******************************************************'
tx_montyp="
aseqdump   completo
note       notas
cc         control change
psc        transport
pc         program change
syx        sysex
rpn        rpn
sr         all System Real-Time messages
sc         all System Common messages"
tx_frshhlp="        ...> "
tx_hlptermhd1='ramiho Rpi MIDI Host - AYUDA
********************************************
     //    Para salir
     +     Conectar puertos
     -     Desconectar puertos
    BSp    Conectar en modo exclusivo
     *     Conectar / Desconectar todo
     .     Desconectar todo
	 
     0     Menú Conexiones Favoritas

     1     Lista de puertos y conexiones
     2     Detalles ALSA MIDI
     3     Detalles dispositivos USB

     4     Menú Conexiones Favoritas
     5     Front-end midish
     6     Leer puerto N

     7     Monitor puerto MIDI
     8     Enviar señal MIDI
	 
     9     Mostrar IP y Ayuda
     99    Leer IP y Ayuda
     98    Activar/Desactivar sonido
     97    Cambiar idioma
    FNC    Leer el puerto n
********************************************'
txhlpcli='ramiho Rpi MIDI Host - Ayuda Linea de Comandos
*************************************************************
Uso:
ramiho               abrir interface en terminal
ramiho $1 $2$3       argumentos para uso en línea de comandos

argumentos: 
   +   > Conectar puertos
 +$1$2 > Conectar puerto número $1 al puerto número $2
   -   > Desconectar puertos
 -$1$2 > Desconectar puerto número $1 del puerto número $2
 
   .   > Desconectar todo
   0   > Menú Conexiones Favoritas
   0$1 > Cargar Conexión Favorita número $1
   1   > Lista de puertos y conexiones
   2   > Mostrar detalles ALSA MIDI
   3   > Mostrar dispositivos USB
   4   > Conectar todos los puertos entre sí
   5   > front-end midish
   6   > Leer puerto N
   6$1 > Leer puerto $1
   7   > Monitor puerto MIDI
   8   > Enviar señal MIDI
   9   > Mostrar IP y Ayuda'

tx_monhd="ramiho >> Elegir puerto y tipo de monitor MIDI
********************************************************************"

tx_smhdr="ramiho >> Enviar señal MIDI
************************************************
   Enter   envía nota
    + -    cambiar nota
    3 9    cambiar octava
    4 6    cambiar canal MIDI
    2 8    cambiar cliente
    0 .    panic
     1     alternar tipo de cliente (hw o virtual)
     7     cargar valores por defecto
     5     enviar secuencia
     /     volver
   FUNC    leer el puerto n
************************************************"

}
fLOCALE_EN () {
txconf_locale="EN"
tx_localch="ramiho in English"
tx_sndon="Sound on"
tx_sndoff="Sound off"
tx_checkfavdev="Check favorite devices:"
tx_errnofavdev="  No favorite devices connected"
tx_retrmh=" Return to ramiho"
tx_errsel="Error introducing selection"
tx_cnx="ramiho_fav> "
tx_mdshprompt="ramiho_midish> "
tx_svcnx="  Save current connexions"
tx_svpos="Choose position (1, 2 or 3)> "
tx_svd="Saved connexions:"
tx_mdshsvd="Connexions saved in "
tx_ldcnx="  Load saved connexions "
tx_midishfront=" Reroute ports and channels"
tx_midishfr2=" When defining ports, channels and connexions, send Enter on an empty prompt to move forward"
tx_ctlc="    Ctrl + C to exit"
tx_mdshdel="9 delete MIDI routings"
tx_rdport="Reed port N"
tx_rdportprmpt="Port N> "
tx_errnpt1="     Port number "
tx_errnpt2=" does not exist"
tx_lstcnx="List of connexions"
tx_err0cnx=" No active connexions!"
tx_lstcnxprt="List of ports and connexions"
tx_lstprt="List of available ports"
tx_hdprt="     N   Port   Name"
tx_lstusb="List of USB buses"
tx_cnxinp1="Enter ports using the position (N) of the port, or format .14.0 (for port 14:0)"
tx_cnxinppr1="First port> "
tx_cnxinppr2="Second port> "
tx_errprt=" Error entering ports"
tx_midicnx="MIDI connexion between ports"
tx_errcnx="Error, couldn't connect"
tx_midicnxex="Exclusive MIDI connexion between ports"
tx_mididcnt="Disconnect ports"
tx_cnctall="Connect all ports with each other"
tx_clsall="Close all MIDI connexions"
tx_smprompt="ramiho_sendmidi> "
tx_monprompt="ramiho_monitor> "
tx_monfrhd="Enter to start monitor for "
tx_montyp="Type of Monitor"
tx_monclt="Client "
tx_arrtyphd="Choose port (up / down)"
tx_arrtphd2="Sel  N   [port]   Client"
tx_arrtphd3="Choose type of monitor (RePag / AvPag)"
tx_anyky="Press any key to exit the monitor"
tx_mondeac="Closing monitor for "
tx_errcli="Error, client not identified"
tx_prt2allhd="Connect to all ports"
tx_all2prthd="Connect from all ports"
tx_monhd2="MIDI monitor for port N"
tx_lstprthd="Sel  N    Client   [port]       Channel    Note n"
tx_detcnxprt="ALSA Detailed connexions"
tx_mdshoutin="Create input devices"
tx_mdshoutout="Create ouput devices"
tx_mdshprtin="N input port "
tx_mdshchin="    input MIDI channel "
tx_mdshprtout="N output port "
tx_mdshchout="   output MIDI channel "
tx_mdshlstin="Input devices"
tx_mdshlstout="Output devices"
tx_mdshcnxhd="Connect input devices with output devices"
tx_mdshcnxin="Connect device > input"
tx_mdshcnxout="   with device > output"
tx_mdshtrans="   transpose (st) > "
tx_mdshsnd="Sending..."
tx_errmdshf="First create a define new midish connexions"
tx_seemdsh="Last midish connexion details"
tx_exitsl="  /   to exit> "
tx_exitout="  Bye..." 
tx_monheader='ramiho >> MIDI monitor
*******************************************************'
tx_montyp="
aseqdump   completo
note       notas
cc         control change
psc        transport
pc         program change
syx        sysex
rpn        rpn
sr         all System Real-Time messages
sc         all System Common messages"
tx_frshhlp="        ...> "
tx_hlptermhd1='ramiho Rpi MIDI Host - HELP
**********************************
     //    To Exit
     +     Connect ports
     -     Disconnect ports
    BSp    Connect ports on exclusive mode
     *     Connect / Disconnect all
     .     Disconnect all
	 
     0     Favorite Connexions menu

     1     List of ports and connexions
     2     ALSA MIDI details
     3     USB devices details

     4     Favorite Connexions
     5     midish front-end
     6     Read port N

     7     Monitor MIDI port
     8     Send MIDI signal to port
	 
     9     Show IP and Help
     99    Read IP and Help
     98    Enable/disable sound
     97    Change language
    FNC    Read port N
**********************************'
txhlpcli='ramiho Rpi MIDI Host - CLI HELP
**********************************
Usage:
ramiho               open terminal interface
ramiho $1 $2$3       arguments for command line

arguments: 
   +   > Connect ports
 +$1$2 > Connect port number $1 to port number $2
   -   > Disconnect ports
 -$1$2 > Disconnect port number $1 from port number $2
 
   .   > Disconnect all
   0   > Favorite Connexions menu
   0$1 > Load Favorite Connexion number $1
   1   > List of ports and connexions
   2   > ALSA MIDI details
   3   > USB devices details
   4   > Connect all
   5   > midish front-end
   6   > Read port N
   6$1 > Provide information on port number $1
   7   > Monitor MIDI port
   8   > Send MIDI signal to port
   9   > This help and IP'

tx_monhd="ramiho >> Choose port and type of monitor
********************************************************************"
tx_smhdr="ramiho >> Send MIDI signal
************************************************
   Enter   send note
    + -    change note
    3 9    change octave
    4 6    change MIDI channel
    2 8    change client
    0 .    panic
     1     change type of client (hw o virtual)
     7     reload default values
     5     send sequence
     /     exit
   FUNC    read port n
************************************************"

}

# CONFIGURATION***********************************************************
fCONF () {  # customize
SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]:-$0}"; )" &> /dev/null && pwd 2> /dev/null; )"
aconfiles=("$SCRIPT_DIR/favcnx/aconsvd0" "$SCRIPT_DIR/favcnx/aconsvd1" "$SCRIPT_DIR/favcnx/aconsvd1" "$SCRIPT_DIR/favcnx/aconsvd1")
midishfiles=("$SCRIPT_DIR/favcnx/mdshsvd1" "$SCRIPT_DIR/favcnx/mdshsvd2" "$SCRIPT_DIR/favcnx/mdshsvd3" "$SCRIPT_DIR/favcnx/mdshcnx1" "$SCRIPT_DIR/favcnx/mdshcnx2" "$SCRIPT_DIR/favcnx/mdshcnx3")
sendmidi="$SCRIPT_DIR/srmidi/sendmidi"
receivemidi="$SCRIPT_DIR/srmidi/receivemidi"
midiseq="$SCRIPT_DIR/srmidi/sendmidifile"
tts_on="festival --tts"  #define text-to-sound engine
tts= # $tts_on # uncomment to enable sound by default
fLOCALE_EN # Change this to your preferred locale
}
fCONF
fCONF_LOCALE () { 
_bold
echo
if [[ $txconf_locale == 'ES' ]]; then
	fLOCALE_EN
	echo "$tx_localch"
else
	fLOCALE_ES
	echo "$tx_localch"
fi
_norm
}
fCONF_MUTE () { 
_bold
echo
if [[ $tts != '' ]]; then
	tts=''
	echo "$tx_sndoff"
else
	tts=$tts_on
	echo "Sound on" | $tts > /dev/null 2>&1 &
	echo "$tx_sndon"
fi
_norm
}

# FORMAT*******************
_bold () { 
tput bold
}
_norm () { 
tput sgr0
}
_blanco () { 
tput setaf 7 
}
_amarillo () {
tput setaf 3
}
_verde () {
tput setaf 2
}

# CONEXIONES FAVORITAS--FAVORITE CONNEXIONS*********************************************
# Aquí puedes determinar algunas acciones del menu de conexiones favoritas
# para una conexión favorita, añade la descripción y el código en la función correspondiente
# input 1, 2 y 3 lanzan las funcinoes fFAV_1, fFAV_2 y fFAV_3, pensadas para conexiones aconnect 
# input 4, 5 y 6 para guardar las conexiones actuales, o cargar configuraciones anteriores - No modificar
# input 7 y 8 lanzan las funciones fMSH_1 y fMSH_2, pensadas para conexiones con midish
# imput 9 abre la interface para midish
fFAV_HEADER () {  # customize
echo "ramiho >> Menu de conexiones favoritas
********************************************************************
     /     Volver a ramiho
    FUNC   Leer puerto N
	
     0     Guardar conexiones actuales
     1     Cargar conexiones guardadas (1)
     2     Cargar conexiones guardadas (2)
     3     Cargar conexiones guardadas (3)
	 
     4     Conectar KeyStep y UC33 a Uno MIDI
     5     Conectar KeyStep & UC-33 a Blofeld y Uno MIDI
     6     Conectar KeyStep, UC-33, USB Uno MIDI a Virus por USB
	  
     7     KeyStep & UC33e -> USB MIDI 
	         [KS: ch1->ch1&ch2 / ch3->ch3&ch4 / ch5->ch5...]
     8     KeyStep & UC33e -> USB MIDI 
	         [KS: ch1->ch1&ch2 / ch3->ch3&ch4 / ch5->ch5&ch6&ch7
			      / ch8,ch9->ch8,ch9]
     9     midish 3
	 
     *     Chequear dispositivos favoritos
     .     Desconectar todo
     +     Conectar puertos
     -     Desconectar puertos
********************************************************************"
}
fFAV_ACT () { # customize
if [[ $1 != "" ]]; then  # si no (vacio)=ENTER
	if [[ $1 = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		echo
		case $1 in
			[.]) fMSH_DEL; fCNX_DISCONNECTALL;;
			[0]) fFAV_SAVEFILE;; 
			[1]) fFAV_LOADFILE "${aconfiles[1]}"; fLST_CONNEX;; 
			[2]) fFAV_LOADFILE "${aconfiles[2]}"; fLST_CONNEX;;  
			[3]) fFAV_LOADFILE "${aconfiles[3]}"; fLST_CONNEX;;  
			[4]) fFAV_1; fLST_CONNEX;;  
			[5]) fFAV_2; fLST_CONNEX;; 
			[6]) fFAV_3; fLST_CONNEX;;   
			[7]) fMSH_LOADFILE "${midishfiles[3]}";; 
			[8]) fMSH_LOADFILE "${midishfiles[4]}";;   
			[9]) fMSH_LOADFILE "${midishfiles[5]}";;    
			[+]) fCNX_OPS 'cnx'
				fLST_CONNEX;; 
			[-]) fCNX_OPS 'dcnx'
				fLST_CONNEX;;   
			[*]) fFAV_DEVICE;; 
			*) ci_err1=true;;
		esac
	fi
[[ $ci_err1 == true ]] && echo $tx_errsel && echo "Error, no setup selected" | $tts > /dev/null 2>&1 &
fi
}
fFAV_1 () {  # customize
aconnect -x
_bold
echo " Conectar KeyStep & UC-33 a Uno MIDI"
_norm
aconnect 'UC-33 USB MIDI Controller':0 'USB Uno MIDI Interface':0
aconnect 'KeyStep Pro':0 'USB Uno MIDI Interface':0 
}
fFAV_2 () {  # customize
aconnect -x
_bold
echo " Conectar KeyStep & UC-33 a Blofeld y Uno MIDI"
_norm
aconnect 'UC-33 USB MIDI Controller':0 'USB Uno MIDI Interface':0
aconnect 'KeyStep Pro':0 'USB Uno MIDI Interface':0 
aconnect 'UC-33 USB MIDI Controller':0 'Blofeld':0
aconnect 'KeyStep Pro':0 'Blofeld':0 
}
fFAV_3 () {  # customize
aconnect -x
_bold
echo " Conectar KeyStep, UC-33, USB Uno MIDI a Virus por USB"
_norm
aconnect 'UC-33 USB MIDI Controller':0 'Virus TI':1
aconnect 'KeyStep Pro':0 'Virus TI':1
aconnect 'Arturia BeatStep Pro':0 'Virus TI':1
aconnect 'USB Uno MIDI Interface':0 'Virus TI':1
aconnect 'QUNEO' 'Virus TI':1
}
fFAV_DEVICE () { #checks if the devices in the list are connected  # customize
clfav=
_bold
echo $tx_checkfavdev
_norm
iconnection=`aconnect -i -l`
	[[ "$iconnection" == *"Virus"* ]] && clfav="$clfav 
  Access Virus TI on"
	[[ "$iconnection" == *"BCR"* ]] && clfav="$clfav 
  BCR2000 on"
	[[ "$iconnection" == *"UC-33"* ]] && clfav="$clfav 
  Evolution UC-33 on"
	[[ "$iconnection" == *"KeyStep"* ]] && clfav="$clfav 
  Arturia KeyStep on"
	[[ "$iconnection" == *"BeatStep"* ]] && clfav="$clfav 
  Arturia BeatStep on"
	[[ "$iconnection" == *"AR-96"* ]] && clfav="$clfav 
  Zoom ARQ AR-96 on"
	[[ "$iconnection" == *"USB Uno MIDI"* ]] && clfav="$clfav 
  USB Uno MIDI Interface on"
	[[ "$iconnection" == *"minilogue"* ]] && clfav="$clfav 
  Korg Minilogue XD on"
	[[ "$iconnection" == *"launchpad"* ]] && clfav="$clfav 
  Novation Launchpad"
	[[ "$iconnection" == *"blofeld"* ]] && clfav="$clfav 
  Waldorf Blofeld on"
	[[ "$iconnection" == *"X-TOUCH"* ]] && clfav="$clfav 
  X-Touch Mini on"
	[[ "$iconnection" == *"QUNEO"* ]] && clfav="$clfav 
  QuNeo on"
if [[ $clfav == '' ]]; then
	echo "No favorites connected" | $tts > /dev/null 2>&1 &
	echo $tx_errnofavdev 
else
	echo "$clfav" | $tts > /dev/null 2>&1 &
	echo "$clfav"
fi
}

fFAV_FRONT () {
setup=
ci_err1=false
ci_err2=false
echo "Choose setup number" | $tts > /dev/null 2>&1 &
	clear
	_bold
	fFAV_HEADER
	fLST_CONNEX
while true; do
	_bold
	_amarillo
	read -n 1 -p $tx_cnx setup 
	read -t 0.01 resto
	[[ $setup == '/' ]] && echo "$tx_retrmh" && break
	_norm
	fFAV_ACT "$setup"
done
}
fFAV_SAVEFILE () { # guarda un fichero con las conexiones actuales aconnect
fREAD_ARRPORTS
_bold
echo  $tx_svcnx
_norm
if [[ -z $1 ]]; then
	savedconnexions="${aconfiles[0]}"
	read -n 1 -p "$tx_svpos" fichern
	case $fichern in # comprobar si el primer caracter de la respuesta coincide
		[1]) savedconnexions="${aconfiles[0]}";;
		[2]) savedconnexions="${aconfiles[1]}";;
		[3]) savedconnexions="${aconfiles[2]}";;
	esac
else
	savedconnexions="${aconfiles[$1]}"
fi
echo > "$savedconnexions"
_bold
echo "  en $savedconnexions"
_norm
Puerto1=
Puerto2=
Clientes=
Clientesn=
Clientesn0=
Clienter=
puertoto=
arrpuertoto=()
let iconnex=0
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do
	if [[ $ilinea -ge 5 ]]; then
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then
			Puerto1=${arrayline[1]}
			Puerto1=$(echo "${Puerto1//:/}")
			let icliente=$icliente+1
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then #SI ES UN NUMERO
			Puerto2=${arrayline[0]}
			puertofr="$Puerto1:$Puerto2"
		elif [[ ${arrayline[0]} == "Connecting" ]]; then
			for puertoto in ${line:15}
			do
				puertoto=$(echo "${puertoto//,/}")
				puertoto=$(echo "${puertoto//'[ex]'/}")
				arrpuertoto+=("$puertoto")
			done

			for i in "${!arrPuerto[@]}";
			do
				if [[ "${arrPuerto[$i]}" == "$puertofr" ]];
				then
					Clientes="${arrCliente[$i]}" && Clientesn="$i"
				fi
			done

			for i in "${!arrPuerto[@]}";
			do
				for y in "${!arrpuertoto[@]}";
				do
					if [[ "${arrPuerto[$i]}" == "${arrpuertoto[$y]}" ]];
					then
						Clienter="${arrCliente[$i]}" && Clientern="$i"
						Clienterpt="${arrPuerto[$i]}"
						puertox2=$(echo "${Clienterpt//*:/}")
						let iconnex=$iconnex+1
						[[ $iconnex == 1 ]] && echo && echo $tx_svd
						echo  "aconnect "\'"$Clientes"\'":$Puerto2 "\'"$Clienter"\'":$puertox2"
						echo  "aconnect "\'"$Clientes"\'":$Puerto2 "\'"$Clienter"\'":$puertox2" >> "$savedconnexions"
					
					fi
				done
			done
		fi
	fi
	let ilinea=$ilinea+1
puertoto=
arrpuertoto=()
done <<< `aconnect -l`
}
fFAV_LOADFILE () { # carga el fichero con conexiones aconnect
savedconnexions="$1"
_bold
echo "$tx_ldcnx $savedconnexions"
_norm
aconnect -x
source "$savedconnexions"
}

# midish*****************************************************************************************************
fMSH_HEADER () {  # customize
clear
_bold
echo "ramiho >> Midish front-end
********************************************************************
     /     Volver a ramiho
    FUNC   Leer puerto N
	
     *     Iniciar conexiones midish
     0     Guardar conexiones midish
	 
     1     Cargar conexiones midish (1)
     2     Cargar conexiones midish (2)
     3     Cargar conexiones midish (3)
	 
     4     KeyStep & UC33e -> USB MIDI 
	         [KS: ch1->ch1&ch2 / ch3->ch3&ch4 / ch5->ch5...]
     5     KeyStep & UC33e -> USB MIDI 
	         [KS: ch1->ch1&ch2 / ch3->ch3&ch4 / ch5->ch5&ch6&ch7
			      / ch8,ch9->ch8,ch9]
     6     midish 3
	 
     7     Cargar conexión en memoria
     8     Ver conexión en memoria
     9     Mostrar esta ayuda

	 
     .     Desconectar todo
     +     Conectar puertos
     -     Desconectar puertos
********************************************************************"
}
fMSH_ACTIONS () {  # customize
if [[ $1 != "" ]]; then  # si no (vacio)=ENTER
	if [[ $1 = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		echo
		case $1 in  
			[*]) fMSH_NEWCNX;; 
			[.]) fMSH_DEL; fCNX_DISCONNECTALL;;
			[0]) fMSH_SAVEFILE;; 
			[1]) fMSH_LOADFILE "${midishfiles[0]}";; 
			[2]) fMSH_LOADFILE "${midishfiles[1]}";;  
			[3]) fMSH_LOADFILE "${midishfiles[2]}";;  
			[4]) fMSH_LOADFILE "${midishfiles[3]}";;  
			[5]) fMSH_LOADFILE "${midishfiles[4]}";; 
			[6]) fMSH_LOADFILE "${midishfiles[5]}";;   
			[7]) fMSH_START;; 
			[8]) fMSH_SEECNX;;   
			[9]) fMSH_HEADER;;    
			[+]) fCNX_OPS 'cnx'
				fLST_CONNEX;; 
			[-]) fCNX_OPS 'dcnx'
				fLST_CONNEX;; 
			*) ci_err1=true;;
		esac
	fi
else
	fMSH_START
# [[ $ci_err1 == true ]] && echo $tx_errsel && echo "Error, no setup selected" | $tts > /dev/null 2>&1 &
fi
}
fMSH_FRONT () {
setup=
ci_err1=false
ci_err2=false
echo "Choose setup number" | $tts > /dev/null 2>&1 &
	fMSH_HEADER
while true; do
	_bold
	_amarillo
	read -n 1 -p $tx_mdshprompt setup 
	read -t 0.01 resto
	[[ $setup == '/' ]] && echo "$tx_retrmh" && break
	_norm
	fMSH_ACTIONS "$setup"
done
}
fMSH_SAVEFILE () { # guarda un fichero con las conexiones actuales
error=false
if [[ "$midishout" == '' ]]; then
	echo "$tx_errmdshf"
else
	_bold
	echo  $tx_svcnx
	_norm
	savedconnexions="${midishfiles[0]}"
	read -n 1 -p "$tx_svpos" fichern
	case $fichern in # uno de los tres ficheros midish
		[1]) savedconnexions="${midishfiles[0]}";;
		[2]) savedconnexions="${midishfiles[1]}";;
		[3]) savedconnexions="${midishfiles[2]}";;
		*) error=true
	esac
	if [[ $error == false ]]; then
		echo "#!/bin/sh
		midish -b <<END"  > "$savedconnexions"
		echo "$midishout" >> "$savedconnexions"
		echo "
		END" >> "$savedconnexions"
		echo
		echo "$tx_mdshsvd $savedconnexions"
	else
		echo "$tx_errprt"
	fi
fi
}
fMSH_LOADFILE () { # carga el fichero con las conexiones guardadas
savedconnexions="$1"
fMSH_DEL > /dev/null 2>&1 &
_bold
echo "$tx_ldcnx $savedconnexions"
_norm
if [[ -f "$savedconnexions" ]]; then
	source "$savedconnexions"
	midishout=$(tail -n +3 "$savedconnexions")
	midishout=$(echo "$midishout" | sed '$d')
else
	echo "$tx_errmdshf"
fi
}
fMSH_SEECNX () {
if [[ "$midishout" == '' ]]; then
	echo "$tx_errmdshf"
else
	_bold
	echo "$tx_seemdsh"
	_norm
	echo "$midishout"
fi
}
fMSH_NEWCNX () { 
_bold
echo $tx_midishfront
_norm
echo $tx_midishfr2
_bold
echo $tx_ctlc 
echo
_norm
fLST_PORTS
fMSH_INPUT
if [[ $ci_err == 'false' ]]; then
	fMSH_START
fi
}
fMSH_INPUT () { #utilidad para recibir input de puertos y canales para operar con midish
fREAD_ARRPORTS
fMSH_DEL  > /dev/null 2>&1 &
midishout=
puertos=
puertor=
canalS=()
canalR=()
portS=()
portR=()
pSalida=
pRecep=
lstportE=
lstportR=
ci_err=false
let icontN=0
let icontS=1
let icontR=1
let icontC=0
for i in "${!arrCliente[@]}"; # por cada puerto MIDI existente (arrCliente en lugar de arrPuerto)
do
	if [[ $icontN -gt 0 ]]; then
		midishout="$midishout
 dnew $icontN \"${arrCliente[$i]}\" rw"
	fi
	let icontN=$icontN+1
done
_bold
echo
echo "$tx_mdshoutin"
_norm
while [[ $ci_err == false ]]; do
	echo "Enter input port number" | $tts > /dev/null 2>&1 &
	read -p "$tx_mdshprtin (input$icontS)> " res1
	if [[ $res1 == '' ]]; then
			tput cuu 1
			tput el 1
		if [[ $icontS -eq 1 ]]; then
			ci_err=true
		else
			echo
			break
		fi
	elif [[ $res1 =~ ^-?[0-9]+$ ]] && [[ $res1 -gt 0 ]]; then
		echo "Enter midi channel" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshchin (input$icontS)> " resch1
		if [[ $resch1 == '' ]]; then
			resch1=any
		elif [[ $resch1 =~ ^-?[0-9]+$ ]] && [[ $resch1 -gt 0 ]] && [[ $resch1 -le 16 ]]; then
			let resch1=$resch1-1
		else
			ci_err=true
		fi
	else
		ci_err=true
	fi
	if [[ $ci_err == false ]]; then
		midishout="$midishout
 inew input$icontS {$res1 $resch1}"
		lstportE="$lstportE    inew input$icontS {$res1 $resch1}
"
	fi
	let icontS=$icontS+1
done
_bold
echo "$tx_mdshoutout"
_norm
while [[ $ci_err == false ]]; do
	echo "Enter output port number" | $tts > /dev/null 2>&1 &
	read -p "$tx_mdshprtout (output$icontR)> " res2
	if [[ $res2 == '' ]]; then
			tput cuu 1
			tput el 1
		if [[ $icontR -eq 1 ]]; then
			ci_err=true
		else
			echo
			break
		fi
	elif [[ $res2 =~ ^-?[0-9]+$ ]] && [[ $res2 -gt 0 ]]; then
		echo "Enter midi channel" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshchout (output$icontR)> " resch2
		# echo
		if [[ $resch2 == '' ]]; then
			resch2=any
		elif [[ $resch2 =~ ^-?[0-9]+$ ]] && [[ $resch2 -gt 0 ]] && [[ $resch2 -le 16 ]]; then
			let resch2=$resch2-1
		else
			ci_err=true
		fi
	else
		ci_err=true
	fi
	if [[ $ci_err == false ]]; then
		midishout="$midishout
 onew output$icontR {$res2 $resch2}"
		lstportR="$lstportR    onew output$icontR {$res2 $resch2}
    "
	fi
	let icontR=$icontR+1
done	
if [[ $ci_err == false ]]; then
	midishout="$midishout
 fnew midishfilter"
	_bold
	echo "$tx_mdshlstin"
	echo "$lstportE"
	echo "$tx_mdshlstout"
	echo "$lstportR"
	echo "$tx_mdshcnxhd"
	_norm
	while [[ $ci_err == false ]]; do
		echo "Connect input and export clients" | $tts > /dev/null 2>&1 &
		read -p "$tx_mdshcnxin" res3
		if [[ $res3 == '' ]] && [[ $icontC -gt 0 ]]; then
			tput cuu 1
			tput el 1
			break 2
		elif [[ $res3 =~ ^-?[0-9]+$ ]]; then
			read -p "$tx_mdshcnxout" res4
			if [[ $res4 =~ ^-?[0-9]+$ ]]; then
				midishout="$midishout
 fmap {any input$res3} {any output$res4}"
				read -p "$tx_mdshtrans" res5
				if [[ $res5 != 0 ]] && [[ $res5 != '' ]]; then
				[[ $res5 -le 0 ]] && res5="($res5)"
					midishout="$midishout
 ftransp {note output$res4} $res5"
				fi
			else
				ci_err=true
			fi
		else
			ci_err=true
		fi

		let icontC=$icontC+1
	done	
fi
if [[ $ci_err == true ]]; then
	_bold
	echo
	echo "$tx_errprt"
	midishout=
else
	midishout="$midishout
i"
fi
}
fMSH_START () { 
if [[ "$midishout" == '' ]]; then
	echo "$tx_errmdshf"
else
	_bold
	echo "$tx_mdshsnd 
$midishout"
	_norm
	echo "$midishout" | midish -b
fi
}
fMSH_DEL () { 
_bold
echo
echo $tx_mdshdel
_norm
aconnect -x
echo s | midish -b
echo fdel | midish -b
echo freset | midish -b
}

# UTILIDADES****************************************************************************************
fREAD_ARRPORTS () { # genera unos arrays con la lista de puertos y nombres de los clientes conectados
puerto1=
puerto2=
puertoc=
arrPuerto=()
arrCliente=()
arrClienteN=()
arrPuerto+=('')
arrCliente+=('')
arrClienteN+=('')
let totpuertos=0
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 5 ]]; then # nos saltamos las cuatro primeras
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then # si la línea comienza con client
			puerto1=${arrayline[1]}
			puerto1=$(echo "${puerto1//:/}")
			nombrepuerto="${arrayline[@]:2}"
			nombrepuerto=$(echo "${nombrepuerto//' ['*/}")
			nombrepuerto=$(echo "${nombrepuerto//\'/}")
			
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then # si la línea comienza con un número
			puerto2=${arrayline[0]}
			puertoc="$puerto1:$puerto2" # puerto de envío en formato 14:0
			arrPuerto+=("$puertoc")
			arrCliente+=("$nombrepuerto")
			if [[ "$puerto2" == '0' ]]; then
				arrClienteN+=("$nombrepuerto")
			else
				arrClienteN+=("$nombrepuerto:$puerto2")
			fi
			let totpuertos=$totpuertos+1
		fi
	fi
	let ilinea=$ilinea+1
done <<< `aconnect -l`
}
fREAD_PORTINFO () { # utilidad para leer el puerto N que llega como argumento
fREAD_ARRPORTS
if [[ -z "$1" ]]; then
	echo "Read port's number " | $tts > /dev/null 2>&1 &
	_bold
	echo "$tx_rdport"
	_norm
	fLST_PORTS
	read -n 1 -p "$tx_rdportprmpt" resp
	if [[ $resp =~ ^-?[0-9]+$ ]]; then
		_norm
		echo
		fREAD_PORTINFO $resp
	else
		echo
	fi
else
	if [[ -z "${arrPuerto[$1]}" ]]; then
		echo "$tx_errnpt1 $1 $tx_errnpt2"
		echo "Error. Port number $1 does not exist" | $tts > /dev/null 2>&1 &
	else
		echo "device number $1. client ${arrCliente[$1]}, port ${arrPuerto[$1]}"  | $tts > /dev/null 2>&1 &
		echo "     $1   ${arrCliente[$1]} [${arrPuerto[$1]}]" 
		fREAD_CONEXINFO "$1"
	fi
fi
}
fREAD_CONEXINFO () { # imprime la lista de conexiones  // !!! ¿la usamos para algo?
fREAD_ARRPORTS
texreco=
Puerto1=
Puerto2=
Clientes=
Clientesp=
Clientesn=
Clientesn0=
Clienter=
aClienterp=()
puertoto=
let ipuerto=0
[[ ! -z "$1" ]] && let ipuerto=$1
let iconnex=0
let ilinea=0
_bold
[[ $ipuerto -eq 0 ]] && echo "$tx_lstcnx"
_norm
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 5 ]]; then # nos saltamos las cuatro primeras
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then # si la línea comienza con client
			Puerto1=${arrayline[1]}
			Puerto1=$(echo "${Puerto1//:/}")
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then # si la línea comienza con un número
			Puerto2=${arrayline[0]}
			Clientesp="$Puerto1:$Puerto2" # puerto de envío en formato 14:0
			for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
			do
				if [[ "${arrPuerto[$i]}" == "$Clientesp" ]]; # si es el puerto de envío, recuperamos su nombre y N
				then
					Clientes="${arrCliente[$i]}" && Clientesn="$i"
				fi
			done
		elif [[ ${arrayline[0]} == "Connecting" ]]; then # si la línea comienza con Connecting entonces...			
			for puertoto in ${line:15}
			do
				puertoto=$(echo "${puertoto//,/}")
				puertoto=$(echo "${puertoto//'[ex]'/}")
				aClienterp+=("$puertoto") # array de puertos de recepción
			done			
			if [[ $ipuerto -eq 0 ]] || [[ $Clientesn -eq "$ipuerto" ]]; then
				for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
				do
					for y in "${!aClienterp[@]}";
					do
						if [[ "${arrPuerto[$i]}" == "${aClienterp[$y]}" ]]; # si es el puerto de destino, recuperamos su nombre y N
						then
							Clienter="${arrCliente[$i]}" && Clientern="$i"
							let iconnex=$iconnex+1
							[[ $ipuerto -eq 0 ]] && [[ $iconnex == 1 ]] && _bold && echo "     N   cliente [puerto] conectado  a  N  cliente [puerto]" && _norm
							if [[ "$Clientesn" != "$Clientesn0" ]]; then # generamos la línea que se va a imprimir
								[[ $ipuerto -eq 0 ]] && echo "     $Clientesn   $Clientes [$Clientesp]"
								echo "            a   $Clientern  $Clienter [${aClienterp[$y]}]"
								Clientesn0=$Clientesn
							else
								echo  "            a   $Clientern  $Clienter [${aClienterp[$y]}]"
							fi
						fi
					done
				done
			fi
			texreco=$texreco". Connexion $iconnex. $Clientes connected to $Clienter"
		fi
	fi
	let ilinea=$ilinea+1
	puertoto=
	aClienterp=()
done <<< `aconnect -l`
if [[ $ipuerto -eq 0 ]] && [[ $iconnex -eq 0 ]]; then
	tput cuu1
	tput el
	_bold
	echo "$tx_err0cnx"
	_norm
fi
}
fREAD_ARRCON () { 
fREAD_ARRPORTS
Puerto1=
Puerto2=
Clientes=
Clientesp=
Clientesn=
Clientesn0=
Clienter=
aClienterp=()
puertoto=
aconenviop=()
aconenvionu=()
aconenviono=()
aconrecepp=()
aconrecepnu=()
aconrecepno=()
let iconnex=0
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 5 ]]; then # nos saltamos las cuatro primeras
			arrayline=($line)
		if [[ ${arrayline[0]} == "client" ]]; then # si la línea comienza con client
			Puerto1=${arrayline[1]}
			Puerto1=$(echo "${Puerto1//:/}")
		elif [[ ${arrayline[0]} =~ ^-?[0-9]+$ ]]; then # si la línea comienza con un número
			Puerto2=${arrayline[0]}
			Clientesp="$Puerto1:$Puerto2" # puerto de envío en formato 14:0
				for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
				do
					if [[ "${arrPuerto[$i]}" == "$Clientesp" ]]; # si es el puerto de envío, recuperamos su nombre y N
					then
						Clientes="${arrCliente[$i]}" && Clientesn="$i"
					fi
				done
				aconenviop+=("$Clientesp")
				aconenvionu+=("$Clientesn")
				aconenviono+=("$Clientes")
				aconrecepp+=("")
				aconrecepnu+=("")
				aconrecepno+=("")
		elif [[ ${arrayline[0]} == "Connecting" ]]; then # si la línea comienza con Connecting entonces...
			for puertoto in ${line:15}
			do
				puertoto=$(echo "${puertoto//,/}")
				puertoto=$(echo "${puertoto//'[ex]'/}")
				aClienterp+=("$puertoto") # array de puertos de recepción
			done
			if [[ $ipuerto -eq 0 ]] || [[ $Clientesn -eq "$ipuerto" ]]; then
				for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
				do
					for y in "${!aClienterp[@]}";
					do
						if [[ "${arrPuerto[$i]}" == "${aClienterp[$y]}" ]]; # si es el puerto de destino, recuperamos su nombre y N
						then
							Clienter="${arrCliente[$i]}" && Clientern="$i"
							let iconnex=$iconnex+1
							aconenviop+=("$Clientesp")
							aconenvionu+=("$Clientesn")
							aconenviono+=("$Clientes")
							aconrecepp+=("${aClienterp[$y]}")
							aconrecepnu+=("$Clientern")
							aconrecepno+=("$Clienter")
						fi
					done
				done
			fi
		fi
	fi
	let ilinea=$ilinea+1
	puertoto=
	aClienterp=()
done <<< `aconnect -l`
}
fLST_CONNEX () { # imprime la lista de conexiones
fREAD_ARRCON
_bold
echo "$tx_lstcnxprt "
_norm
let icontador=1
puerto0=
for i in "${!aconenviop[@]}"; 
do
	[[ "$puerto0" != "${aconenviop[$i]}" ]] && _bold && echo "     ${aconenvionu[$i]}   ${aconenviono[$i]}   [${aconenviop[$i]}]" && _norm
	[[ "${aconrecepnu[$i]}" != '' ]] && echo "            "$'\U2192'"   ${aconrecepnu[$i]}   ${aconrecepno[$i]}   [${aconrecepp[$i]}]"
	let icontador=$icontador+1
	puerto0="${aconenviop[$i]}"
done
}
fLST_PORTS () { # imprime la lista de clientes
fREAD_ARRPORTS
texrecl=
_bold
echo "$tx_lstprt"
_norm
let ipuerto=0
for i in "${arrPuerto[@]}"
do
   [[ $ipuerto == 0 ]] && _bold && echo "$tx_hdprt" && _norm
   [[ $ipuerto != 0 ]] && echo "     $ipuerto   $i   ${arrClienteN[$ipuerto]}" && texrecl=$texrecl". Device number $ipuerto. client ${arrCliente[$ipuerto]}, port ${i:0:2}, ${i:3:1}"
   let ipuerto=$ipuerto+1
done
}
fLST_USB () { # imprime la lista de dispositivos USB conectados
_bold
echo "$tx_lstusb"
_norm
lsusb
}
fLST_ALSADETAILS () {
_bold
echo "$tx_lstprt"		
_norm
aplaymidi -l
echo
_bold
echo "$tx_detcnxprt"
_norm	
aconnect -l			
}

# CONEXIONES***********************************************************************************************
fCNX_OPS () { # entrada para las conexiones
cnxtyp=$1
cnxoper=
_bold
if [[ $cnxtyp == 'cnx' ]]; then
	echo "$tx_midicnx"
	cnxoper=''
elif [[ $cnxtyp == 'dcnx' ]]; then
	echo "$tx_mididcnt"
	cnxoper='-d '
elif [[ $cnxtyp == 'excl' ]]; then
	echo "$tx_midicnxex"
	cnxoper='-e '
else
	ci_err=true
fi
fLST_CONNEX
_norm
fCNX_INPUT $2 $3
if [[ $ci_err == false ]]; then
	echo
	echo "aconnect $cnxoper $puertos $puertor"
	aconnect $cnxoper $puertos $puertor
	[[ $? != 0 ]] && echo "$tx_errcnx"
fi
}
fCNX_INPUT () { #utilidad para recibir input de índices o puertos para operar aconnect. Si se usan las FUNC se envían los índices
fREAD_ARRPORTS
puertos=
puertor=
nombres=
nombrer=
ci_err=false
ci_all=false
if [[ -z "$1" ]]; then
	_bold
	echo "Enter first port " | $tts > /dev/null 2>&1 &
	echo
	echo "$tx_cnxinp1"
	_norm
	_verde
	read -n 1 -p "$tx_cnxinppr1"  res1
	_norm
	if [[ $res1 =~ ^-?[0-9]+$ ]]; then
		if [[ $res1 -le ${#arrPuerto[@]} ]]; then
			puertos=${arrPuerto[res1]}
			nombres=${arrClienteN[res1]}
		else
			ci_err=true
		fi
	elif [[ $res1 == '*' ]]; then
		ci_all=true
	elif [[ $res1 == '' ]]; then
		ci_err=true
	elif [[ $res1 == '.' ]]; then
		read res1
		res1=$(echo "${res1//../:}")
		puertos=$res1
		# nombres=${arrClienteN[res1]}
	else # si res1 no está vacío ni empieza por un número (N) o un punto, asumimos que se están usando las FUNC del NumPad y comparamos el 3er caracter
		read -n 1 resp2 
		read -n 1 resp3
		read -t 0.01 resto
		case $resp3 in
			[4F]) let res1=1;; # End
			[B]) let res1=2;;  # Flecha Dn
			[6]) let res1=3;;  # Pg Dn / Av Pag
			[D]) let res1=4;; # Flecha Lft
			[EG]) let res1=5;; # (5) en el centro de las flechas
			[C]) let res1=6;; # Flecha Rgt
			[1H]) let res1=7;; # Home
			[A]) let res1=8;; # Flecha Up
			[5]) let res1=9;;  # Pg Up / Re Pag
			*) ci_err=true;;
		esac
		if [[ $res1 =~ ^-?[0-9]+$ ]]; then
			puertos=${arrPuerto[res1]}
			nombres=${arrClienteN[res1]}
		else
			ci_err=true
			res1=
		fi
	fi
	if [[ $ci_err == false ]]; then
		echo "Enter second port" | $tts > /dev/null 2>&1 &
		echo
		_verde
		read -n 1 -p "$tx_cnxinppr2" res2
		_norm
		if [[ $ci_all == 'true' ]]; then
			if [[ $res2 == '*' ]] || [[ $res2 == '' ]]; then
				if [[ $cnxtyp == 'cnx' ]]; then
					fCNX_CONNECTALL
				else
					fCNX_DISCONNECTALL
				fi
			else
				fCNX_ALL2PRT $res2
				ci_err=true
			fi
		elif [[ $res2 == '*' ]]; then
			fCNX_PRT2ALL $res1
			ci_all=true
			ci_err=true
		elif [[ $res2 =~ ^-?[0-9]+$ ]]; then
			if [[ $res1 -le ${#arrPuerto[@]} ]]; then
				puertor=${arrPuerto[res2]}
				nombrer=${arrClienteN[res2]}
			else
				ci_err=true
			fi
		elif [[ $res2 == '' ]]; then
			ci_err=true
			echo "Error"
		elif [[ $res2 == '.' ]]; then
			read res2
			res2=$(echo "${res2//../:}")
			puertor=$res2
			nombrer=${arrClienteN[res2]}
		else
			read -n 1 resp2 # se guardan los primeros tres caracteres de la respuesta para buscar equivalencias
			read -n 1 resp3
			read -t 0.01 resto
			case $resp3 in
				[4F]) let res2=1;; # End
				[B]) let res2=2;;  # Flecha Dn
				[6]) let res2=3;;  # Pg Dn / Av Pag
				[D]) let res2=4;; # Flecha Lft
				[EG]) let res2=5;; # (5) en el centro de las flechas
				[C]) let res2=6;; # Flecha Rgt
				[1H]) let res2=7;; # Home
				[A]) let res2=8;; # Flecha Up
				[5]) let res2=9;;  # Pg Up / Re Pag
				*) ci_err=true;;
			esac
			if [[ $res2 =~ ^-?[0-9]+$ ]]; then
				puertor=${arrPuerto[res2]}
				nombrer=${arrClienteN[res2]}
			else
				ci_err=true
				res2=
			fi
		fi
	fi
else
	if [[ $1 == 'simball' ]]; then
		if [[ $2 == 'simball' ]] || [[ $2 == '' ]]; then
			if [[ $cnxtyp == 'cnx' ]]; then
				fCNX_CONNECTALL
			elif [[ $cnxtyp == 'dcnx' ]]; then
				fCNX_DISCONNECTALL
			fi
		else
			fCNX_ALL2PRT $2
		fi
	elif [[ $2 == 'simball' ]]; then
		fCNX_PRT2ALL $1
	else
		puertos=${arrPuerto[$1]}
		nombres=${arrClienteN[$1]}
		puertor=${arrPuerto[$2]}
		nombrer=${arrClienteN[$2]}
	fi
fi
if [[ $ci_err == true ]] && [[ $ci_all == false ]]; then
	_bold
	echo
	echo "$tx_errprt"
fi
}
fCNX_PRT2ALL () {
indpuertos="$1"
ci_err=true
ci_all=true
echo "$tx_prt2allhd"
for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
do
	if [[ $i -ge 1 ]] && [[ $i != $indpuertos ]]; then
		puertos=${arrPuerto[$indpuertos]}
		nombres=${arrClienteN[$indpuertos]}
		puertor=${arrPuerto[$i]}
		nombrer=${arrClienteN[$i]}
		aconnect $cnxoper $puertos $puertor 2>/dev/null
	fi
done
}
fCNX_ALL2PRT () {
indpuertor="$1"
ci_err=true
ci_all=true
echo "$tx_all2prthd"
for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
do
	if [[ $i -ge 1 ]] && [[ $i != $indpuertor ]]; then
		puertos=${arrPuerto[$i]}
		nombres=${arrClienteN[$i]}
		puertor=${arrPuerto[$indpuertor]}
		nombrer=${arrClienteN[$indpuertor]}
		aconnect $cnxoper $puertos $puertor 2>/dev/null
	fi
done
}
fCNX_CONNECTALL() { # conectar todos los puertos MIDI entre si
fREAD_ARRPORTS
connectall=true
arrConPE=()
arrConPR=()
arrConCE=()
arrConCR=()
let icuentax=0
let icuentay=0
aconnect -x
_bold
echo "$tx_cnctall" 
echo
_norm
for i in "${arrPuerto[@]}"
do
	for n in "${arrPuerto[@]}"
	do
		if [[ "$i" != "$n" ]] && [[ "${arrCliente[icuentax]}" != "${arrCliente[icuentay]}" ]] && [[ $icuentax -ge 1 ]] && [[ $icuentay -ge 1 ]]; then 
			aconnect $i $n 
				if [[ $? == 0 ]]; then 
					arrConPE+=("$i") && arrConPR+=("$n") && arrConCE+=("${arrCliente[icuentax]}") && arrConCR+=("${arrCliente[icuentay]}")
				else
					echo Error en el intento de conectar ${arrCliente[icuentax]} -> ${arrCliente[icuentay]}
				fi
		fi
	let icuentay=$icuentay+1
	done
	let icuentay=0
	let icuentax=$icuentax+1
done
}
fCNX_DISCONNECTALL () { # desconectar todos los puertos MIDI entre si
connectall=false
_bold
echo "$tx_clsall"
_norm
aconnect -x
}

# MONITOR*MIDI**************************************************
fMON_FRONT () { # interface del monitor de puertos MIDI
let montipnum=1
let iportout=1
fMON_LISTPORT
montipo=${arrtipomonitor[$montipnum]}
devicename=${arrClienteN[$iportout]}
tout="monitor $devicename $montipo"
while true; do
	errorc=
	clear
	_bold
	_norm
	fMON_LISTPORT
	_bold
	echo '*******************************************************'
	echo
	echo "$tx_monfrhd [${arrPuerto[$iportout]}] ${arrCliente[$iportout]} ($montipo)"
	if [[ $send == true ]]; then
		send=false
		if [[ $montipo == 'aseqdump' ]]; then
			fMON_ASEQ $iportout
		else
			fMON_RM $montipo
		fi
	fi
	_amarillo
	read -s -n 1 -p "$tx_monprompt" resp
	read -n 1 -t 0.05 caracter2
	read -n 1 -t 0.01 caracter3
	read -t 0.01 resto
	# echo -en "\r\033[K" # borra la línea anterior (prompt de read y respuesta)
	_norm
	_blanco
	if [[ $resp == '' ]]; then
		send=true
		tout="monitor $devicename $montipo"
	elif [[ $resp = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		case $resp in # comprobar si el primer caracter de la respuesta coincide
			[/q]) echo "$tx_retrmh"
				break;;
			[9]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum-1
				[[ $montipnum -eq 0 ]] && let montipnum=9
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";;
			[3]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum+1
				[[ $montipnum -eq 10 ]] && let montipnum=1
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";;
			[2]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrCliente[@]} ]] && let iportout=$iportout-1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};;
			[8]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};;
			*) #si no se encuentran coincidencias para $resp
				errorc=true;;
		esac
		case $caracter3 in # para usar con flechas
			[6]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum-1
				[[ $montipnum -eq 0 ]] && let montipnum=9
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";; # Flecha Lft
			[5]) montipo0=${arrtipomonitor[$montipnum]}
				let montipnum=$montipnum+1
				[[ $montipnum -eq 10 ]] && let montipnum=1
				montipo=${arrtipomonitor[$montipnum]}
				tout=$tx_montyp" $montipo0 > $montipo";; # Flecha Rgt
			[B]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrCliente[@]} ]] && let iportout=$iportout-1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};;  # Flecha Dn¡
			[A]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout=$tx_monclt"${arrPuerto[$iportout0]} > ${arrPuerto[$iportout]}    ${arrCliente[$iportout]} [${arrPuerto[$iportout]}]"
				devicename=${arrClienteN[$iportout]};; # Flecha Up
			*) ci_err2=true;;
		esac
		[[ $ci_err2 == true ]] && echo $tx_errsel && echo "Error on selection" | $tts > /dev/null 2>&1 &
	fi
done
}
fMON_ARRTYP () {
arrtipomonitor=()
arrtipomonitor+=("aseqdump")
arrtipomonitor+=("aseqdump")
arrtipomonitor+=("note")
arrtipomonitor+=("cc")
arrtipomonitor+=("start stop cont")
arrtipomonitor+=("pc")
arrtipomonitor+=("syx")
arrtipomonitor+=("rpn")
arrtipomonitor+=("sr")
arrtipomonitor+=("sc")
}
fMON_LISTPORT () {
fREAD_ARRPORTS
_bold
echo "$tx_monheader"
echo "$tx_arrtyphd"
_norm
let icontador=0
for i in "${!arrPuerto[@]}"; # por cada puerto MIDI existente
do
	if [[ $icontador == 0 ]]; then
		_bold
		echo "$tx_arrtphd2"
		_norm
	elif [[ $icontador -eq $iportout ]]; then
		_bold
		echo " X   $icontador    [${arrPuerto[$icontador]}]   ${arrCliente[$icontador]} "
		_norm
	else
		echo "     $icontador    [${arrPuerto[$icontador]}]   ${arrCliente[$icontador]}  "

	fi
	let icontador=$icontador+1
done
let icontador=0
echo
_bold
echo "$tx_arrtphd3"
_norm
TAB="$(printf '\t')"
while IFS= read -r line; do # por cada puerto MIDI existente
	if [[ $icontador -eq 0 ]]; then
		_bold
		echo "Sel   Monitores"
		_norm
	elif [[ $icontador -eq $montipnum ]]; then
		_bold
		echo " ->  $icontador    $line"
		_norm
	else
		echo "     $icontador    $line"
	fi
	let icontador=$icontador+1
done <<< "$tx_montyp"
}
fMON_ASEQ () { # monitor MIDI usando aseqdump
puertom=${arrPuerto[$1]}
if [[ $devicename == '' ]]; then
	devicename=${arrClienteN[$1]}
fi
if [[ $puertom != '' ]]; then
	echo 
	echo aseqdump -p $puertom
	aseqdump -p $puertom &
	PID=$!
	echo
	echo "Monitor de $devicename ($PID)"
	sleep 1
	_bold
	echo "$tx_anyky" # se cancela la monitorización tocando cualquier tecla
	_norm
	read -n 1 resto
		echo 
		echo "$tx_mondeac $devicename ($PID)"
		kill -INT $PID && PID=
else
	echo
	echo "$tx_errcli" 
fi
}
fMON_RM () { # monitor MIDI usando receivemidi
tipomonit=$1
puertom=${arrPuerto[$iportout]}
clientem=${arrClienteN[npm]}
_bold
echo "$tx_monhd2" 
echo
_norm
if [[ $puertom != '' ]]; then
	echo 
	echo receivemidi dev $devicename $tipomonit
	_bold
	echo $tx_ctlc
	_norm
	echo
	$receivemidi dev $devicename $tipomonit
	echo
else
	echo
	echo "$tx_errcli"
fi

}
fMON_ARRTYP

# SEND*MIDI***********************************************************
fSM_FRONT () { # enviar señal midi a los puertos con sendmidi
let iportout=1
let smch=1
let smoct=0
let smnot=48
let iportout0=0
let smch0=1
let smoct0=3
let smnot0=48
send=false
devicename=
clienttyp='dev'
clienttypout=
fSM_LISTPORT
devicename=${arrClienteSM[$iportout]}
tout="sendmidi $clienttyp $devicename ch $smch on $smnot 127 clock 120 off $smnot 127"
while true; do
	errorc=
	clear
	_bold
	echo "$tx_smhdr "
	_norm
	fSM_LISTPORT
	echo
	echo "$tout"
	[[ $send == true ]] && send=false && $("$sendmidi" $clienttyp "$devicename" ch $smch on $smnot 127 clock 120 off $smnot 127)
	_bold
	_amarillo
	read -s -n 1 -p "$tx_smprompt" resp
	read -n 1 -t 0.05 caracter2
	read -n 1 -t 0.01 caracter3
	read -t 0.01 resto
	_norm
	# echo -en "\r\033[K" # borra la línea anterior (prompt de read y respuesta)
	_norm
	_blanco
	if [[ $resp == '' ]]; then
		send=true
		tout="sendmidi $clienttyp $devicename ch $smch on $smnot 127 clock 120 off $smnot 127"
	elif [[ $resp = "" ]]; then # si borrar (Backspace) entonces
		echo "$tx_retrmh"
		break
	else
		case $resp in # comprobar si el primer caracter de la respuesta coincide
			[/q]) echo "$tx_retrmh"
				break;;
			[5]) tout="Mandar secuencia"
				x=$("$sendmidi" $clienttyp $devicename ch $smch file "$midiseq" );;
			[0..]) echo "Panic!"
				x=$("$sendmidi" $clienttyp $devicename panic) ;;
			[1]) if [[ $clienttyp == 'dev' ]]; then
					clienttyp='virt'
					clienttypout='[vir]'
				else
					clienttyp='dev'
					clienttypout=
				fi
				tout="Tipo de cliente $clienttyp";;
			[7]) let smch=1
				let smoct=0
				let smnot=48
				tout="Cargar valores por defecto";;
			[+]) let smnot0=$smnot
				let smnot=$smnot+1
				[[ $smnot -ge 128 ]] && let smnot=127
				tout="Nota $smnot0 > $smnot";;
			[-]) let smnot0=$smnot
				let smnot=$smnot-1
				[[ $smnot -le 0 ]] && let smnot=0
				tout="Nota $smnot0 > $smnot";;
			[8]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]}
				;;
			[2]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrClienteSM[@]} ]] && let iportout=$iportout-1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]}
				;;
			[3]) let smoct=-1
				let smnot0=$smnot
				let smnot=$smnot+$smoct*12
				[[ $smnot -ge 128 ]] && let smnot=127
				tout="(-Oct) Nota $smnot0 > $smnot"
				let smoct=0;; 
			[9]) let smoct=1
				let smnot0=$smnot
				let smnot=$smnot+$smoct*12
				[[ $smnot -ge 128 ]] && let smnot=127
				tout="(+Oct) Nota $smnot0 > $smnot"
				let smoct=0;;
			[4]) let smch0=$smch
				let smch=$smch-1
				[[ $smch -eq 0 ]] && let smch=16
				echo "Canal MIDI $smch0 > $smch";;
			[6]) let smch0=$smch
				let smch=$smch+1
				[[ $smch -eq 17 ]] && let smch=1
				tout="Canal MIDI $smch0 > $smch";;
			*) #si no se encuentran coincidencias para $resp
				errorc=true;;
		esac
		case $caracter3 in # para usar con flechas
			[B]) let iportout0=$iportout
				let iportout=$iportout+1
				[[ $iportout -ge ${#arrClienteSM[@]} ]] && let iportout=$iportout-1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]};;  # Flecha Dn¡
			[D]) let smch0=$smch
				let smch=$smch-1
				[[ $smch -eq 0 ]] && let smch=16
				echo "Canal MIDI $smch0 > $smch";; # Flecha Lft
			[C]) let smch0=$smch
				let smch=$smch+1
				[[ $smch -eq 17 ]] && let smch=1
				tout="Canal MIDI $smch0 > $smch";; # Flecha Rgt
			[A]) let iportout0=$iportout
				let iportout=$iportout-1
				[[ $iportout -le 1 ]] && let iportout=1
				tout="Cliente ${arrClienteSM[$iportout0]} > ${arrClienteSM[$iportout]}    ${arrCliente[$iportout]}"
				devicename=${arrClienteSM[$iportout]};; # Flecha Up
			*)	#si no se encuentran coincidencias para $resp
				errorc=true;;
		esac
	fi
done
}
fSM_LISTPORT () {
fSM_READARRPORTS
let icontador=0
for i in "${!arrClienteSM[@]}"; # por cada puerto MIDI existente
do
	if [[ $icontador == 0 ]]; then
		_bold
		echo "$tx_lstprthd"
		_norm
	elif [[ $icontador -eq $iportout ]]; then
		_bold
		echo " X   $icontador    ${arrClienteSM[$icontador]}    ch$smch    n$smnot"
		_norm

	else
		echo  "     $icontador    ${arrClienteSM[$icontador]}  "

	fi
	let icontador=$icontador+1
done
}
fSM_READARRPORTS () { # genera unos arrays con la lista de puertos y nombres de los clientes conectados
arrClienteSM=()
arrClienteSM+=('')
let ilinea=0
TAB="$(printf '\t')"
while IFS= read -r line; do # leemos cada línea de aconnect -l
	if [[ $ilinea -ge 1 ]]; then # nos saltamos las primera linea	
		arrClienteSM+=("$line")
	fi
	let ilinea=$ilinea+1
done <<< `$sendmidi list`
}

# CABECERAS*AYUDA******************************************************
fHLP_HEADER () { # pantalla de ayuda
_norm
_bold	
echo "$tx_hlptermhd1"
}
fHLP_READ () { # lector con tts de la ayuda
texthelp="Raspi Midi Host.
slash to exit.
plus to connect ports.
minus to disconnect ports.
dot to disconnect all.
0 to connect all.
9 to read raspi's IP number"
echo $texthelp | $tts > /dev/null 2>&1 &
}

# RAMIHO*FRONT***********************************************************
fRMH_FRONT () { # loop del entorno interactivo RMH
while true; do
	errorc=
	_verde
	_bold
	read -n 1 -p "ramiho> " caracter1 # usamos el primer y tercer caracteres de la respuesta para buscar equivalencias
	read -n 1 -t 0.05 caracter2
	read -n 1 -t 0.01 caracter3
	read -t 0.01 resto
	echo
	_blanco
		if [[ $caracter1 = "" ]]; then # si borrar (Backspace) entonces
			fCNX_OPS 'excl'
			fLST_CONNEX
		else
			case $caracter1 in # comprobar si el primer caracter de la respuesta coincide
				[*]) if [[ $connectall == 'true' ]]; then
						fCNX_DISCONNECTALL
					else
						fCNX_CONNECTALL
						fLST_CONNEX
					fi;;
				[/q]) fRMH_EXIT;;
				[+]) fCNX_OPS 'cnx'
					fLST_CONNEX;; 
				[-]) fCNX_OPS 'dcnx'
					fLST_CONNEX;;
				[..,]) fCNX_DISCONNECTALL;;
				[0]) fFAV_FRONT;;
				[1]) fLST_CONNEX; echo "$texrecl. $texreco" | $tts > /dev/null 2>&1 &;;
				[2]) fLST_ALSADETAILS;;
				[3]) fLST_USB;;
				[4]) fFAV_FRONT;;
				[5]) fMSH_FRONT;;
				[6]) fREAD_PORTINFO ;;
				[7]) fMON_FRONT;;
				[8]) fSM_FRONT;;
				[9]) read -n 1 -t 1 -p "$tx_frshhlp" dosnueve
					leerIP=`hostname -I`
					if [[ $dosnueve -eq 9 ]]; then
						clear
						# echo $leerIP
						fCONF_MUTE
						fHLP_HEADER
						echo $leerIP | $tts > /dev/null 2>&1
						fHLP_READ
					elif [[ $dosnueve -eq 8 ]]; then
						fCONF_MUTE
					elif [[ $dosnueve -eq 7 ]]; then
						fCONF_LOCALE
					else
						clear
						echo $leerIP
						fHLP_HEADER
					fi
					dosnueve=;;
				*) #si no se encuentran coincidencias para $caracter1
					errorc=true;;
			esac
			case $caracter3 in # para teclas especiales como flechas, Inicio, Fin, etc. comprobamos el tercer caracter guardado
				[2]) fCNX_CONNECTALL
					fLST_CONNEX;; # Ins
				[3]) fCNX_DISCONNECTALL;;  # Del
				[4F]) fREAD_PORTINFO 1;; # End
				[B]) fREAD_PORTINFO 2;;  # Flecha Dn
				[6]) fREAD_PORTINFO 3;;  # Pg Dn / Av Pag
				[D]) fREAD_PORTINFO 4;; # Flecha Lft
				[EG]) fREAD_PORTINFO 5;; # (5) en el centro de las flechas
				[C]) fREAD_PORTINFO 6;; # Flecha Rgt
				[1H]) fREAD_PORTINFO 7;; # Home
				[A]) fREAD_PORTINFO 8;; # Flecha Up
				[5]) fREAD_PORTINFO 9;;  # Pg Up / Re Pag
				*)	[[ $errorc == true  ]] && echo "...";;
			esac
		fi
done
}
fRMH_START () {
echo "Welcome to ra mi ho" | $tts > /dev/null 2>&1 &
fFAV_LOADFILE "${aconfiles[0]}" > /dev/null 2>&1
clear
fHLP_HEADER
fLST_CONNEX
fRMH_FRONT
}
fRMH_EXIT () { # menu para salir
echo "slash to exit" | $tts > /dev/null 2>&1 &
_bold
_amarillo
# tput cuu 1
read -n 1 -p "$tx_exitsl" iexit
if [[ $iexit == '/' ]]; then
	echo "$tx_exitout"
	echo "Good vibe" | $tts > /dev/null 2>&1 &
	_norm
	fFAV_SAVEFILE 0 > /dev/null 2>&1
	exit 0
fi
_blanco
echo
}

# CLI
if [[ $# -ge 1 ]]; then # si se ejecutó con argumentos
	for arg in "$@"; do 
		if [[ $arg == 'mute' ]]; then
				tts=
				fRMH_START
		elif [[ $arg == '/'* ]]; then
			inumcli=${arg:1}
			tts=
			fREAD_PORTINFO $inumcli
		elif [[ $arg == +* ]]; then
			pt1=
			pt2=
			if [[ ${arg:1:1} == '*' ]]; then # si no expande el * y no funciona...
				pt1='simball'
			else
				pt1=${arg:1:1}				
			fi
			if [[ ${arg:2:1} == '*' ]]; then
				pt2='simball'
			else
				pt2=${arg:2:1}				
			fi
			fCNX_OPS 'cnx' $pt1 $pt2
			fLST_CONNEX
		elif [[ $arg == -* ]]; then
			pt1=
			pt2=
			pt1=${arg:1:1}
			pt2=${arg:2:1}
			fCNX_OPS 'dcnx' "$pt1 $pt2"
			fLST_CONNEX
		# elif [[ $arg == '*'* ]]; then
		elif [[ $arg == '.' ]] | [[ $arg == ',' ]]; then
			fCNX_DISCONNECTALL
			fLST_CONNEX
		elif [[ $arg == 0* ]]; then
			inumcli=${arg:1}
			if [[ -z "$inumcli" ]]; then
				fFAV_FRONT
			else
				fFAV_ACT "$inumcli"
			fi		
		elif [[ $arg == 1 ]]; then
			fLST_CONNEX
		elif [[ $arg == 2 ]]; then
			fLST_ALSADETAILS
		elif [[ $arg == 3 ]]; then
			fLST_USB
		elif [[ $arg == 4 ]]; then
			fCNX_CONNECTALL
			fLST_CONNEX
		elif [[ $arg == 5 ]]; then
			fMSH_FRONT
		elif [[ $arg == 6* ]]; then
			inumcli=${arg:1}
			fREAD_PORTINFO $inumcli
		elif [[ $arg == 7* ]]; then
			inumcli=${arg:1}
			if [[ -z "$inumcli" ]]; then
				fMON_FRONT
			else
				fREAD_ARRPORTS
				fMON_ASEQ $inumcli
			fi
		elif [[ $arg == 8 ]]; then
			fSM_FRONT
		elif [[ $arg == 9 ]]; then
			hostIP=`hostname -I`
			echo "$txhlpcli"
			echo $hostIP
		fi
	done
else # si se ejecutó sin argumentos, entrar en el loop
	fRMH_START
fi
exit 0
		
# RECURSOS
	# RASPBERRY PI AS USB/BLUETOOTH MIDI HOST
	# https://neuma.studio/rpi-midi-complete.html
	#
	# LINUX MIDI CHEATSHEET 
	# https://mclarenlabs.com/blog/2018/07/03/linux-midi-cheatsheet/
	#
	# Shell programming with bash: by example, by counter-example
	# https://matt.might.net/articles/bash-by-example/
	#
	# the ALSA system exposes many of its details through the /proc/asound filesystem
	# cat /proc/asound/seq/clients
	#
# HERRAMIENTAS / DEBUGGING TOOLS
	# CREAR puertos virtuales:
	# sudo modprobe snd-virmidi snd_index=1
	# o
	# sudo modprobe snd-virmidi enable=1,1 midi_devs=4,1
	# BORRAR los puertos virtuales:
	# sudo modprobe -r snd-virmidi
	#
	# dmesg to see messages about USB devices being plugged and unplugged. Use this if you are unsure if your equipment is being recognized by your system. The [-w] option makes dmesg wait for new messages.
	#
	# lsusb to list the USB devices currently connected to your system. Use this if you are unsure if your keyboard or controller is being recognized as a USB device.